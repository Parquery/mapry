"""Generate the C++ code to parse and serialize a mapry object graph."""
import collections
from typing import List

import mapry
import mapry.cpp.naming

WARNING = "// File automatically generated by mapry. DO NOT EDIT OR APPEND!"


def comment(text: str) -> str:
    """
    Comment out the given the text.

    :param text: of the comment
    :return: non-indented comment
    """
    comment_lines = []  # type: List[str]
    for line in text.splitlines():
        if line.strip():
            comment_lines.append('// {}'.format(line))
        else:
            comment_lines.append('//')

    return '\n'.join(comment_lines)


def type_repr(a_type: mapry.Type, cpp: mapry.Cpp) -> str:
    """
    Generate the C++ type representation of the given mapry type.

    :param a_type: in mapry
    :param cpp: C++ settings
    :return: C++ type as a string
    """
    # pylint: disable=too-many-return-statements
    # pylint: disable=too-many-branches
    if isinstance(a_type, mapry.Boolean):
        return "bool"

    elif isinstance(a_type, mapry.Integer):
        return "int64_t"

    elif isinstance(a_type, mapry.Float):
        return "double"

    elif isinstance(a_type, mapry.String):
        return "std::string"

    elif isinstance(a_type, mapry.Path):
        if cpp.path_as == "std::filesystem::path":
            return "std::filesystem::path"

        elif cpp.path_as == "boost::filesystem::path":
            return "boost::filesystem::path"

        else:
            raise NotImplementedError(
                "C++ representation of schema.cpp.path_as: {}".format(
                    cpp.path_as))

    elif isinstance(a_type, mapry.Date):
        if cpp.datetime_library == 'ctime':
            return "struct tm"
        elif cpp.datetime_library == 'date.h':
            return "date::local_days"
        else:
            raise NotImplementedError(
                "Unhandled datetime library: {}".format(cpp.datetime_library))

    elif isinstance(a_type, mapry.Time):
        if cpp.datetime_library == 'ctime':
            return "struct tm"
        elif cpp.datetime_library == 'date.h':
            return "date::time_of_day<std::chrono::seconds>"
        else:
            raise NotImplementedError(
                "Unhandled datetime library: {}".format(cpp.datetime_library))

    elif isinstance(a_type, mapry.Datetime):
        if cpp.datetime_library == 'ctime':
            return "struct tm"
        elif cpp.datetime_library == 'date.h':
            return "date::local_seconds"
        else:
            raise NotImplementedError(
                "Unhandled datetime library: {}".format(cpp.datetime_library))

    elif isinstance(a_type, mapry.TimeZone):
        if cpp.datetime_library == 'ctime':
            return "std::string"
        elif cpp.datetime_library == 'date.h':
            return "const date::time_zone*"
        else:
            raise NotImplementedError(
                "Unhandled datetime library: {}".format(cpp.datetime_library))

    elif isinstance(a_type, mapry.Duration):
        return "std::chrono::nanoseconds"

    elif isinstance(a_type, mapry.Array):
        return "std::vector<{}>".format(
            type_repr(a_type=a_type.values, cpp=cpp))

    elif isinstance(a_type, mapry.Map):
        return "std::map<std::string, {}>".format(
            type_repr(a_type=a_type.values, cpp=cpp))

    elif isinstance(a_type, mapry.Class):
        return "{}*".format(
            mapry.cpp.naming.as_composite(identifier=a_type.name))

    elif isinstance(a_type, mapry.Embed):
        return mapry.cpp.naming.as_composite(identifier=a_type.name)

    else:
        raise NotImplementedError(
            "Unhandled C++ represenation of a type: {}".format(type(a_type)))


def escaped_str(text: str) -> str:
    r"""
    Convert the ``text`` into a C++ escaped string.

    :param text: to be converted
    :return: C++ string literal

    >>> escaped_str(text='testme')
    '"testme"'

    >>> escaped_str(text='test"me')
    '"test\\"me"'

    """
    # yapf: disable
    mapping = collections.OrderedDict([
        ('\\', '\\\\'),
        ('"', '\\"'),
        ('\a', '\\a'),
        ('\b', '\\b'),
        ('\t', '\\t'),
        ('\n', '\\n'),
        ('\v', '\\v'),
        ('\f', '\\f'),
        ('\r', '\\r'),
        ('\x1B', '\\e')])
    # yapf: enable

    result = text
    for src, tgt in mapping.items():
        result = result.replace(src, tgt)

    return '"{}"'.format(result)
