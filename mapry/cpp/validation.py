"""Validate that the C++ code can be generated according to the schema."""
from typing import (  # pylint: disable=unused-import
    Dict, List, Mapping, MutableMapping)

import mapry
import mapry.cpp
import mapry.cpp.naming
import mapry.validation

_KEYWORDS = {
    'alignas', 'alignof', 'and', 'and_eq', 'asm', 'atomic_cancel',
    'atomic_commit', 'atomic_noexcept', 'auto', 'bitand', 'bitor', 'bool',
    'break', 'case', 'catch', 'char', 'char16_t', 'char32_t', 'class', 'compl',
    'concept', 'const', 'constexpr', 'const_cast', 'continue', 'co_await',
    'co_return', 'co_yield', 'decltype', 'default', 'delete', 'do', 'double',
    'dynamic_cast', 'else', 'enum', 'explicit', 'export', 'extern', 'false',
    'float', 'for', 'friend', 'goto', 'if', 'import', 'inline', 'int', 'long',
    'module', 'mutable', 'namespace', 'new', 'noexcept', 'not', 'not_eq',
    'nullptr', 'operator', 'or', 'or_eq', 'private', 'protected', 'public',
    'register', 'reinterpret_cast', 'requires', 'return', 'short', 'signed',
    'sizeof', 'static', 'static_assert', 'static_cast', 'struct', 'switch',
    'synchronized', 'template', 'this', 'thread_local', 'throw', 'true', 'try',
    'typedef', 'typeid', 'typename', 'union', 'unsigned', 'using', 'virtual',
    'void', 'volatile', 'wchar_t', 'while', 'xor', 'xor_eq'
}


class _Field:
    """Represent a C++ field of a composite."""

    def __init__(self, name: str, ref: str) -> None:
        """
        Initialize the C++ field of a composite with the given values.

        :param name: name of the composite field
        :param ref: reference path in the mapry schema of this field
        """
        self.name = name
        self.ref = ref


def _properties_to_fields(properties: Mapping[str, mapry.Property]
                          ) -> List[_Field]:
    """
    Convert properties of a mapry composite into a list of C++ composite fields.

    :param properties: of a composite
    :return: list of fields.
    """
    # yapf: disable
    return [
        _Field(name=mapry.cpp.naming.as_field(identifier=prop.name),
               ref=prop.ref)
        for prop in properties.values()]
    # yapf: enable


def _validate_fields(fields: List[_Field]
                     ) -> List[mapry.validation.SchemaError]:
    """
    Validate the correctness of the the corresponding C++ fields of a composite.

    Notably, we validate that there are  no duplicates and no reserved keywords
    in the C++ fields of a composite.

    :param fields: C++ fields corresponding to the composite
    :return: list of errors, or an empty list if no errors
    """
    errs = []  # type: List[mapry.validation.SchemaError]

    name_to_fields = dict()  # type: Dict[str, _Field]

    for field in fields:
        if field.name in _KEYWORDS:
            errs.append(
                mapry.validation.SchemaError(
                    message=(
                        "The C++ field identifier {!r} "
                        "is a keyword in C++").format(field.name),
                    ref=field.ref))

        if field.name in name_to_fields:
            errs.append(
                mapry.validation.SchemaError(
                    message=(
                        "The C++ field identifier {!r} "
                        "conflicts another field ({})").format(
                            field.name, name_to_fields[field.name].ref),
                    ref=field.ref))
        else:
            name_to_fields[field.name] = field

    return errs


def _validate_class_fields(a_class: mapry.Class
                           ) -> List[mapry.validation.SchemaError]:
    """
    Validate that the properties of the class can be translated to C++ fields.

    :param a_class: definition of a mapry class
    :return: list of errors, or an empty list if no errors
    """
    errs = []  # type: List[mapry.validation.SchemaError]

    fields = _properties_to_fields(properties=a_class.properties)
    errs.extend(_validate_fields(fields=fields))

    for field in fields:
        if field.name == 'id':
            errs.append(
                mapry.validation.SchemaError(
                    message=(
                        "The C++ field identifier {!r} is reserved for "
                        "class identifiers and "
                        "used by the autogenerated code").format(field.name),
                    ref=field.ref))
    return errs


def _validate_embed_fields(embed: mapry.Embed
                           ) -> List[mapry.validation.SchemaError]:
    """
    Check the translation of the properties of the embeddable structure to C++.

    :param embed: definition of an embeddable structure
    :return: list of errors, or an empty list if no errors
    """
    errs = []  # type: List[mapry.validation.SchemaError]

    fields = _properties_to_fields(properties=embed.properties)
    errs.extend(_validate_fields(fields=fields))

    return errs


def _validate_graph_fields(graph: mapry.Graph
                           ) -> List[mapry.validation.SchemaError]:
    """
    Check the translation of the object graph to C++.

    :param graph: mapry definition of the object graph
    :return: list of errors, or an empty list if no errors
    """
    errs = []  # type: List[mapry.validation.SchemaError]

    fields = _properties_to_fields(properties=graph.properties)
    errs.extend(_validate_fields(fields=fields))

    property_field_map = {field.name: field for field in fields}
    registry_field_map = dict()  # type: MutableMapping[str, mapry.Class]

    for cls in graph.classes.values():
        plural_field = mapry.cpp.naming.as_field(identifier=cls.plural)

        if plural_field in _KEYWORDS:
            errs.append(
                mapry.validation.SchemaError(
                    message=(
                        "The C++ field identifier {!r} corresponding "
                        "to the registry of the class {!r} in the object "
                        "graph is a reserved keyword in C++").format(
                            plural_field, cls.name),
                    ref=cls.ref))

        if plural_field in property_field_map:
            errs.append(
                mapry.validation.SchemaError(
                    message=(
                        "The C++ field identifier {!r} corresponding "
                        "to the registry of the class {!r} in the object "
                        "graph conflicts with another C++ field corresponding "
                        "to a property of the object graph ({})").format(
                            plural_field, cls.name,
                            property_field_map[plural_field].ref),
                    ref=cls.ref))

        if plural_field in registry_field_map:
            errs.append(
                mapry.validation.SchemaError(
                    message=(
                        "The C++ field identifier {!r} corresponding "
                        "to the registry of the class {!r} in the object "
                        "graph conflicts with the C++ field corresponding to "
                        "another registry of the class {!r} ({})").format(
                            plural_field, cls.name,
                            registry_field_map[plural_field].name,
                            registry_field_map[plural_field].ref),
                    ref=cls.ref))
        else:
            registry_field_map[plural_field] = cls

    return errs


def validate_schema(schema: mapry.Schema) -> List[mapry.validation.SchemaError]:
    """
    Validate that we can generate the C++ code for the given mapry schema.

    :param schema: mapry schema
    :return: list of errors, or an empty list if no errors
    """
    name_to_composite = dict()  # type: Dict[str, mapry.Composite]

    errs = []  # type: List[mapry.validation.SchemaError]

    graph_name = mapry.cpp.naming.as_composite(identifier=schema.graph.name)
    if graph_name in _KEYWORDS:
        errs.append(
            mapry.validation.SchemaError(
                message=(
                    "C++ identifier ({!r}) corresponding to the name of "
                    "the object graph ({!r}) is a keyword in C++").format(
                        graph_name, schema.graph.name),
                ref=schema.graph.ref))

        name_to_composite[graph_name] = schema.graph

    for cls in schema.graph.classes.values():
        cls_name = mapry.cpp.naming.as_composite(identifier=cls.name)

        # Check that the name is not a keyword
        if cls_name in _KEYWORDS:
            errs.append(
                mapry.validation.SchemaError(
                    message=(
                        "C++ identifier ({!r}) corresponding to the name of "
                        "the class ({!r}) is a keyword in C++").format(
                            cls_name, cls.name),
                    ref=cls.ref))

        # Check that the name is not a duplicate
        if cls_name in name_to_composite:
            conflict_composite = name_to_composite[cls_name]
            errs.append(
                mapry.validation.SchemaError(
                    message=(
                        "Class {!r} and the composite {!r} ({}) "
                        "have conflicting C++ identifiers: {!r}".format(
                            cls.name, conflict_composite.name,
                            conflict_composite.ref, cls_name)),
                    ref=cls.ref))
        else:
            name_to_composite[cls_name] = cls

        # Check that the fields are valid
        errs.extend(_validate_class_fields(a_class=cls))

    for embed in schema.graph.embeds.values():
        embed_name = mapry.cpp.naming.as_composite(identifier=embed.name)
        if embed_name in _KEYWORDS:
            errs.append(
                mapry.validation.SchemaError(
                    message=(
                        "C++ identifier ({!r}) corresponding to the name of "
                        "the embeddable structure ({!r}) "
                        "is a keyword in C++").format(embed_name, embed.name),
                    ref=embed.ref))

        if embed_name in name_to_composite:
            conflict_composite = name_to_composite[embed_name]
            errs.append(
                mapry.validation.SchemaError(
                    message=(
                        "The embeddable structure {!r} "
                        "and the composite {!r} ({}) have "
                        "conflicting C++ identifiers: {!r}".format(
                            embed.name, conflict_composite.name,
                            conflict_composite.ref, embed_name)),
                    ref=embed.ref))
        else:
            name_to_composite[embed_name] = embed

        # Check that the fields are valid
        errs.extend(_validate_embed_fields(embed=embed))

    # Check the fields of the object graph (including the class registries)
    errs.extend(_validate_graph_fields(graph=schema.graph))

    return errs
