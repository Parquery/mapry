"""Generate the Go code to parse and serialize a mapry object graph."""
import collections
import re
from typing import List, Set

import icontract
from icontract import ensure

import mapry
import mapry.naming

WARNING = "// File automatically generated by mapry. DO NOT EDIT OR APPEND!"


def comment(text: str) -> str:
    """
    Comment out the given the text.

    :param text: of the comment
    :return: non-indented comment
    """
    comment_lines = []  # type: List[str]
    for line in text.splitlines():
        if line.strip():
            comment_lines.append('// {}'.format(line))
        else:
            comment_lines.append('//')

    return '\n'.join(comment_lines)


def type_repr(a_type: mapry.Type, go: mapry.Go) -> str:
    """
    Generate the Go type representation of the given mapry type.

    :param a_type: in mapry
    :param go: Go settings
    :return: Go type as a string
    """
    # pylint: disable=too-many-return-statements
    # pylint: disable=too-many-branches
    if isinstance(a_type, mapry.Boolean):
        return "bool"

    elif isinstance(a_type, mapry.Integer):
        return "int64"

    elif isinstance(a_type, mapry.Float):
        return "float64"

    elif isinstance(a_type, mapry.String):
        return "string"

    elif isinstance(a_type, mapry.Path):
        return "string"

    elif isinstance(a_type, mapry.Date):
        return "time.Time"

    elif isinstance(a_type, mapry.Time):
        return "time.Time"

    elif isinstance(a_type, mapry.Datetime):
        return "time.Time"

    elif isinstance(a_type, mapry.TimeZone):
        return "*time.Location"

    elif isinstance(a_type, mapry.Duration):
        return "time.Duration"

    elif isinstance(a_type, mapry.Array):
        return "[]{}".format(type_repr(a_type=a_type.values, go=go))

    elif isinstance(a_type, mapry.Map):
        return "map[string]{}".format(type_repr(a_type=a_type.values, go=go))

    elif isinstance(a_type, mapry.Class):
        return "*{}".format(mapry.naming.ucamel_case(identifier=a_type.name))

    elif isinstance(a_type, mapry.Embed):
        return mapry.naming.ucamel_case(identifier=a_type.name)

    else:
        raise NotImplementedError(
            "Unhandled Go represenation of a type: {}".format(type(a_type)))


@ensure(lambda result: not result.endswith('\n'))
def escaped_str(text: str) -> str:
    r"""
    Convert the ``text`` into a Go escaped string.

    The result will include the prefix and suffix quotes.

    :param text: to be converted
    :return: Go string literal

    >>> escaped_str(text='testme')
    '"testme"'

    >>> escaped_str(text='test"me')
    '"test\\"me"'

    """
    # yapf: disable
    mapping = collections.OrderedDict([
        ('\\', '\\\\'),
        ('"', '\\"'),
        ('\a', '\\a'),
        ('\b', '\\b'),
        ('\t', '\\t'),
        ('\n', '\\n'),
        ('\v', '\\v'),
        ('\f', '\\f'),
        ('\r', '\\r'),
        ('\x1B', '\\e')])
    # yapf: enable

    result = text
    for src, tgt in mapping.items():
        result = result.replace(src, tgt)

    return '"{}"'.format(result)


@ensure(lambda result: not result.endswith('\n'))
def ticked_str(text: str) -> str:
    """
    Convert the ``text`` into a backticked Go string literal.

    If there are backticks in the text, the generated string literal
    is split into multiple lines.

    :param text: to be converted
    :return: Go string literal

    >>> ticked_str(text='testme')
    '`testme`'

    >>> print(ticked_str(text='test`me'))
    `test`+"`"+
        `me`

    """
    tick_parts = text.split('`')
    parts = []  # type: List[str]

    for i, part in enumerate(tick_parts):
        if i == 0:
            parts.append('`{}`'.format(part))
        else:
            parts.append('+"`"+\n    `{}`'.format(part))

    return ''.join(parts)


@ensure(lambda result: not result.endswith('\n'))
def import_declarations(import_set: Set[str]) -> str:
    """
    Generate the import declaration(s) given the import specs.

    :param import_set: import specs
    :return: Go import declaration

    >>> import_declarations(set())
    ''

    >>> import_declarations({'time'})
    'import "time"'

    >>> print(import_declarations({'time', 'regexp'}))
    import (
        "regexp"
        "time"
    )

    """
    if len(import_set) == 0:
        return ''

    elif len(import_set) == 1:
        return 'import "{}"'.format(list(import_set)[0])

    else:
        parts = ['import (\n']
        for package in sorted(import_set):
            parts.append('    "{}"\n'.format(package))
        parts.append(')')
        return ''.join(parts)


class AutoID:
    """Keep track of parsing identifiers."""

    def __init__(self) -> None:
        """Initialize with a zero identifier."""
        self._next_id = 0

    @ensure(
        lambda result: re.match(r'^0|[1-9][0-9]*$', result),
        enabled=icontract.SLOW)
    def next_identifier(self) -> str:
        """
        Generate the next identifier.

        :return: the generated identifier
        """
        result = self._next_id
        self._next_id += 1

        return str(result)


_NONPOINTER_TYPES = (
    mapry.Boolean, mapry.Integer, mapry.Float, mapry.String, mapry.Path,
    mapry.Date, mapry.Time, mapry.Datetime, mapry.Duration, mapry.Embed)

_POINTER_TYPES = (mapry.TimeZone, mapry.Array, mapry.Map, mapry.Class)


def is_pointer_type(a_type: mapry.Type) -> bool:
    """
    Check whether the type is represented as a pointer in Go.

    :param a_type: mapry type definition
    :return: True if the type is represented with a pointer
    """
    if isinstance(a_type, _NONPOINTER_TYPES):
        return False

    elif isinstance(a_type, _POINTER_TYPES):
        return True

    else:
        raise NotImplementedError(
            "Unhandled the mapry type definition: {}".format(a_type))
