"""Validate that the Go code can be generated according to the schema."""
from typing import (  # pylint: disable=unused-import
    Dict, List, Mapping, MutableMapping)

import mapry
import mapry.naming
import mapry.strftime
import mapry.validation

_KEYWORDS = {
    'break', 'default', 'func', 'interface', 'select', 'case', 'defer', 'go',
    'map', 'struct', 'chan', 'else', 'goto', 'package', 'switch', 'const',
    'fallthrough', 'if', 'range', 'type', 'continue', 'for', 'import', 'return',
    'var'
}


class _Field:
    """Represent a Go field of a composite."""

    def __init__(self, name: str, ref: str) -> None:
        """
        Initialize the Go field of a composite with the given values.

        :param name: name of the composite field
        :param ref:
            reference path in the mapry schema corresponding to this field
        """
        self.name = name
        self.ref = ref


def _properties_to_fields(properties: Mapping[str, mapry.Property]
                          ) -> List[_Field]:
    """
    Convert properties of a mapry composite into a list of Go composite fields.

    :param properties: of a composite
    :return: list of fields.
    """
    # yapf: disable
    return [
        _Field(name=mapry.naming.ucamel_case(identifier=prop.name),
               ref=prop.ref)
        for prop in properties.values()
    ]
    # yapf: enable


def _validate_fields(fields: List[_Field]
                     ) -> List[mapry.validation.SchemaError]:
    """
    Validate the fields of a Go struct.

    Notably, check that there are no duplicates and no reserved keywords.

    :param fields: Go fields corresponding to the composite
    :return: list of errors, or an empty list if no errors
    """
    errs = []  # type: List[mapry.validation.SchemaError]

    name_to_fields = dict()  # type: Dict[str, _Field]

    for field in fields:
        if field.name in _KEYWORDS:
            errs.append(
                mapry.validation.SchemaError(
                    message=(
                        "The Go field identifier {!r} "
                        "is a keyword in Go").format(field.name),
                    ref=field.ref))

        if field.name in name_to_fields:
            errs.append(
                mapry.validation.SchemaError(
                    message=(
                        "The Go field identifier {!r} "
                        "conflicts another field ({})").format(
                            field.name, name_to_fields[field.name].ref),
                    ref=field.ref))
        else:
            name_to_fields[field.name] = field

    return errs


def _validate_class_fields(a_class: mapry.Class
                           ) -> List[mapry.validation.SchemaError]:
    """
    Validate that the properties of the class can be translated to Go fields.

    :param a_class: definition of a mapry class
    :return: list of errors, or an empty list if no errors
    """
    errs = []  # type: List[mapry.validation.SchemaError]

    fields = _properties_to_fields(properties=a_class.properties)
    errs.extend(_validate_fields(fields=fields))

    for field in fields:
        if field.name == 'ID':
            errs.append(
                mapry.validation.SchemaError(
                    message=(
                        "The Go field identifier 'ID' is reserved "
                        "for class identifiers and used by the "
                        "autogenerated code"),
                    ref=field.ref))
    return errs


def _validate_embed_fields(embed: mapry.Embed
                           ) -> List[mapry.validation.SchemaError]:
    """
    Validate that the embeddable structure can be translated to Go fields.

    :param embed: definition of an embeddable structure
    :return: list of errors, or an empty list if no errors
    """
    errs = []  # type: List[mapry.validation.SchemaError]

    fields = _properties_to_fields(properties=embed.properties)
    errs.extend(_validate_fields(fields=fields))

    return errs


def _validate_graph_fields(graph: mapry.Graph
                           ) -> List[mapry.validation.SchemaError]:
    """
    Validate that the object graph can be translated into a Go structure.

    :param graph: mapry definition of the object graph
    :return: list of errors, or an empty list if no errors
    """
    errs = []  # type: List[mapry.validation.SchemaError]

    fields = _properties_to_fields(properties=graph.properties)
    errs.extend(_validate_fields(fields=fields))

    property_field_map = {field.name: field for field in fields}
    registry_field_map = dict()  # type: MutableMapping[str, mapry.Class]

    for cls in graph.classes.values():
        plural_field = mapry.naming.ucamel_case(identifier=cls.plural)

        if plural_field in _KEYWORDS:
            errs.append(
                mapry.validation.SchemaError(
                    message=(
                        "The Go field identifier {!r} corresponding "
                        "to the registry of the class {!r} in the object "
                        "graph is a reserved keyword in Go").format(
                            plural_field, cls.name),
                    ref=cls.ref))

        if plural_field in property_field_map:
            errs.append(
                mapry.validation.SchemaError(
                    message=(
                        "The Go field identifier {!r} corresponding "
                        "to the registry of the class {!r} in the object "
                        "graph conflicts with another Go field corresponding "
                        "to a property of the object graph ({})").format(
                            plural_field, cls.name,
                            property_field_map[plural_field].ref),
                    ref=cls.ref))

        if plural_field in registry_field_map:
            errs.append(
                mapry.validation.SchemaError(
                    message=(
                        "The Go field identifier {!r} corresponding "
                        "to the registry of the class {!r} in the object "
                        "graph conflicts with the Go field corresponding to "
                        "another registry of the class {!r} ({})").format(
                            plural_field, cls.name,
                            registry_field_map[plural_field].name,
                            registry_field_map[plural_field].ref),
                    ref=cls.ref))
        else:
            registry_field_map[plural_field] = cls

    reserved_type_names = {
        'Errors', '{}FromJSONable'.format(mapry.naming.ucamel_case(graph.name)),
        '{}ToJSONable'.format(mapry.naming.ucamel_case(graph.name))
    }

    for cls in graph.classes.values():
        reserved_type_names.add(
            '{}FromJSONable'.format(mapry.naming.ucamel_case(cls.name)))
        reserved_type_names.add(
            '{}ToJSONable'.format(mapry.naming.ucamel_case(cls.name)))

    for embed in graph.embeds.values():
        reserved_type_names.add(
            '{}FromJSONable'.format(mapry.naming.ucamel_case(embed.name)))
        reserved_type_names.add(
            '{}ToJSONable'.format(mapry.naming.ucamel_case(embed.name)))

    for cls in graph.classes.values():
        cls_name = mapry.naming.ucamel_case(cls.name)
        if cls_name in reserved_type_names:
            mapry.validation.SchemaError(
                message=(
                    "The Go struct identifier {!r} "
                    "conflicts with the name reserved for mapry."
                ).format(cls_name),
                ref=cls.ref)

    for embed in graph.embeds.values():
        embed_name = mapry.naming.ucamel_case(embed.name)
        if embed_name in reserved_type_names:
            mapry.validation.SchemaError(
                message=(
                    "The Go struct identifier {!r} "
                    "conflicts with the name reserved for mapry."
                ).format(embed_name),
                ref=embed.ref)

    graph_name = mapry.naming.ucamel_case(graph.name)
    if graph_name in reserved_type_names:
        mapry.validation.SchemaError(
            message=(
                "The Go struct identifier {!r} "
                "conflicts with the name reserved for mapry."
            ).format(graph_name),
            ref=graph.ref)

    return errs


# yapf: disable
_GO_TIME_FORMAT_DIRECTIVES = [
    'Sunday',
    'Sun',
    'January',
    'Jan',
    '02',
    '_2',
    '01',
    '2006',
    '06',
    '15',
    '03',
    '3',
    '04',
    'pm',
    'PM',
    '05',
    '-0700',
    'MST'
]


# yapf: enable


def _validate_date_time_formats(graph: mapry.Graph
                                ) -> List[mapry.validation.SchemaError]:
    """
    Validate that all date/time formats can be parsed and serialized in Go.

    :param graph: mapry definition of an object graph
    :return: list of errors, if any
    """
    errs = []  # type: List[mapry.validation.SchemaError]

    # yapf: disable
    date_time_types = ((a_type, ref)
                       for a_type, ref in mapry.iterate_over_types(graph=graph)
                       if isinstance(a_type, (mapry.Date, mapry.Datetime,
                                              mapry.Time)))
    # yapf: enable

    for a_type, ref in date_time_types:
        tkn_lines = mapry.strftime.tokenize(format=a_type.format)

        # yapf: disable
        text_tkns = [
            tkn
            for tkn_line in tkn_lines
            for tkn in tkn_line
            if tkn.identifier == 'text'
        ]
        # yapf: enable

        for tkn in text_tkns:
            for directive in _GO_TIME_FORMAT_DIRECTIVES:
                if directive in tkn.content:
                    if isinstance(a_type, mapry.Date):
                        type_str = 'Date'
                    elif isinstance(a_type, mapry.Datetime):
                        type_str = 'Date/time'
                    elif isinstance(a_type, mapry.Time):
                        type_str = 'Time'
                    else:
                        raise NotImplementedError(
                            "Unhandled mapry type: {}".format(type(a_type)))

                    errs.append(
                        mapry.validation.SchemaError(
                            message=(
                                '{} format contains a conflicting '
                                'Go time.Format directive {}: {}').format(
                                    type_str, directive, a_type.format),
                            ref=ref))
                    break
    return errs


def validate_schema(schema: mapry.Schema) -> List[mapry.validation.SchemaError]:
    """
    Validate that we can generate the Go code for the given mapry schema.

    :param schema: mapry schema
    :return: list of errors, or an empty list if no errors
    """
    name_to_composite = dict()  # type: Dict[str, mapry.Composite]

    errs = []  # type: List[mapry.validation.SchemaError]

    graph_name = mapry.naming.ucamel_case(identifier=schema.graph.name)
    if graph_name in _KEYWORDS:
        errs.append(
            mapry.validation.SchemaError(
                message=(
                    "Go identifier ({!r}) corresponding to the name of "
                    "the object graph ({!r}) is a keyword in Go").format(
                        graph_name, schema.graph.name),
                ref=schema.graph.ref))

        name_to_composite[graph_name] = schema.graph

    for cls in schema.graph.classes.values():
        cls_name = mapry.naming.ucamel_case(identifier=cls.name)

        # Check that the name is not a keyword
        if cls_name in _KEYWORDS:
            errs.append(
                mapry.validation.SchemaError(
                    message=(
                        "Go identifier ({!r}) corresponding to the name of "
                        "the class ({!r}) is a keyword in Go").format(
                            cls_name, cls.name),
                    ref=cls.ref))

        # Check that the name is not a duplicate
        if cls_name in name_to_composite:
            conflict_composite = name_to_composite[cls_name]
            errs.append(
                mapry.validation.SchemaError(
                    message=(
                        "Class {!r} and the composite {!r} ({}) have "
                        "conflicting Go identifiers: {!r}".format(
                            cls.name, conflict_composite.name,
                            conflict_composite.ref, cls_name)),
                    ref=cls.ref))
        else:
            name_to_composite[cls_name] = cls

        # Check that the class field names are valid
        errs.extend(_validate_class_fields(a_class=cls))

    for embed in schema.graph.embeds.values():
        embed_name = mapry.naming.ucamel_case(identifier=embed.name)
        if embed_name in _KEYWORDS:
            errs.append(
                mapry.validation.SchemaError(
                    message=(
                        "Go identifier ({!r}) corresponding to the name of "
                        "the embeddable structure ({!r}) "
                        "is a keyword in Go").format(embed_name, embed.name),
                    ref=embed.ref))

        if embed_name in name_to_composite:
            conflict_composite = name_to_composite[embed_name]
            errs.append(
                mapry.validation.SchemaError(
                    message=(
                        "The embeddable structure {!r} and "
                        "the composite {!r} ({}) have conflicting "
                        "Go identifiers: {!r}".format(
                            embed.name, conflict_composite.name,
                            conflict_composite.ref, embed_name)),
                    ref=embed.ref))
        else:
            name_to_composite[embed_name] = embed

        # Check that the field names are valid
        errs.extend(_validate_embed_fields(embed=embed))

    # Check that the field names of the object graph are valid
    # (including the class registries)
    errs.extend(_validate_graph_fields(graph=schema.graph))

    errs.extend(_validate_date_time_formats(graph=schema.graph))

    return errs
