// File automatically generated by mapry. DO NOT EDIT OR APPEND!

#include "jsoncpp.h"
#include "parse.h"
#include "types.h"

#include <cmath>
#include <cstring>
#include <iomanip>
#include <limits>
#include <memory>
#include <regex>
#include <sstream>
#include <stdexcept>
#include <string>
#include <utility>

namespace some {
namespace graph {

namespace jsoncpp {

/**
 * generates an error message.
 *
 * @param cc char array as the description part of the message
 * @param cc_size size of the char array
 * @param s string as the detail part of the message
 * @return concatenated string
 */
std::string message(const char* cc, size_t cc_size, std::string s) {
  std::string result;
  result.reserve(cc_size + s.size());
  result.append(cc, cc_size);
  result.append(s);
  return result;
}

namespace re {
const std::regex kDuration(
  "^(\\+|-)?P(((0|[1-9][0-9]*)(\\.[0-9]+)?)Y)?"
  "(((0|[1-9][0-9]*)(\\.[0-9]+)?)M)?"
  "(((0|[1-9][0-9]*)(\\.[0-9]+)?)W)?"
  "(((0|[1-9][0-9]*)(\\.[0-9]+)?)D)?"
  "(T"
  "(((0|[1-9][0-9]*)(\\.[0-9]+)?)H)?"
  "(((0|[1-9][0-9]*)(\\.[0-9]+)?)M)?"
  "(((0|[1-9][0-9]*)(\\.([0-9]+))?)S)?"
  ")?$");
}  // namespace re

/**
 * adds the left and the right and checks for the overflow.
 *
 * left and right are expected to be non-negative.
 *
 * @param[in] left summand
 * @param[in] right summand
 * @param[out] overflows true if the addition overflows
 * @return sum
 */
template <typename rep_t>
rep_t add_rep_double(rep_t left, double right, bool* overflows) {
  if (left < 0) {
    throw std::invalid_argument("Expected left >= 0");
  }

  if (right < 0) {
    throw std::invalid_argument("Expected right >= 0");
  }

  // 9223372036854775808 == 2^63, the first double that is
  // greater than max int64 (max int64 is 2^63 - 1).
  if (right >= 9223372036854775808.0) {
    *overflows = true;
    return 0;
  }

  const rep_t rightRep = right;

  if (rightRep > std::numeric_limits<rep_t>::max() - left) {
    *overflows = true;
    return 0;
  }

  return rightRep + left;
}

/**
 * parses the duration from a string.
 *
 *  Following STL chrono library, the following units are counted as:
 *   - years as 365.2425 days (the average length of a Gregorian year),
 *   - months as 30.436875 days (exactly 1/12 of years) and
 *   - weeks as 7 days.
 *
 * See https://en.cppreference.com/w/cpp/chrono/duration for details.
 *
 * @param[in] s string to parse
 * @param[out] error error message, if any
 * @return parsed duration
 */
std::chrono::nanoseconds duration_from_string(
    const std::string& s,
    std::string* error) {
  std::smatch mtch;
  const bool matched = std::regex_match(s, mtch, re::kDuration);

  if (!matched) {
    std::stringstream sserr;
    sserr << "failed to match the duration: " << s;
    *error = sserr.str();
    return std::chrono::nanoseconds();
  }

  typedef std::chrono::nanoseconds::rep rep_t;

  ////
  // Extract nanoseconds
  ////

  const std::string nanoseconds_str = mtch[31];
  rep_t nanoseconds;
  if (nanoseconds_str.size() == 0) {
    // No nanoseconds specified
    nanoseconds = 0;
  } else if(nanoseconds_str.size() <= 9) {
    size_t first_nonzero = 0;
    for (; first_nonzero < nanoseconds_str.size();
        ++first_nonzero) {
      if (nanoseconds_str[first_nonzero] >= '0' and
          nanoseconds_str[first_nonzero] <= '9') {
        break;
      }
    }

    if (first_nonzero == nanoseconds_str.size()) {
      // No non-zero numbers, all zeros behind the seconds comma
      nanoseconds = 0;
    } else {
      const rep_t fraction_as_integer(
        std::atol(&nanoseconds_str[first_nonzero]));

      const size_t order = 9 - nanoseconds_str.size();
      rep_t multiplier = 1;
      for (size_t i = 0; i < order; ++i) {
        multiplier *= 10;
      }

      nanoseconds = fraction_as_integer * multiplier;
    }
  } else {
    // Signal that the precision is lost
    std::stringstream sserr;
    sserr << "converting the duration to nanoseconds "
      "results in loss of precision: " << s;
    *error = sserr.str();
    return std::chrono::nanoseconds();
  }

  ////
  // Extract all the other interval counts
  ////

  const std::string sign_str = mtch[1];
  const rep_t sign = (sign_str.empty() or sign_str == "+") ? 1 : -1;

  const double years(
    (mtch[3].length() == 0) ? 0.0 : std::stod(mtch[3]));
  const double months(
    (mtch[7].length() == 0) ? 0.0 : std::stod(mtch[7]));
  const double weeks(
    (mtch[11].length() == 0) ? 0.0 : std::stod(mtch[11]));
  const double days(
    (mtch[15].length() == 0) ? 0.0 : std::stod(mtch[15]));
  const double hours(
    (mtch[20].length() == 0) ? 0.0 : std::stod(mtch[20]));
  const double minutes(
    (mtch[24].length() == 0) ? 0.0 : std::stod(mtch[24]));
  const rep_t seconds(
    (mtch[29].length() == 0) ? 0 : std::stol(mtch[29]));

  ////
  // Sum
  ////

  rep_t sum = nanoseconds;

  const rep_t max_seconds(
    std::numeric_limits<rep_t>::max() / (1000L * 1000L * 1000L));
  if (seconds > max_seconds) {
    std::stringstream sserr;
    sserr << "seconds in duration overflow as nanoseconds: " << s;
    *error = sserr.str();
    return std::chrono::nanoseconds();
  }

  const rep_t seconds_as_ns = seconds * 1000L * 1000L * 1000L;
  if (sum > std::numeric_limits<rep_t>::max() - seconds_as_ns) {
    std::stringstream sserr;
    sserr << "duration overflow as nanoseconds: " << s;
    *error = sserr.str();
    return std::chrono::nanoseconds();
  }
  sum += seconds_as_ns;

  bool overflows;

  sum = add_rep_double(
    sum, minutes * 6e10, &overflows);
  if (overflows) {
    std::stringstream sserr;
    sserr << "duration overflows as nanoseconds: " << s;
    *error = sserr.str();
    return std::chrono::nanoseconds();
  }

  sum = add_rep_double(
    sum, hours * 3.6e12, &overflows);
  if (overflows) {
    std::stringstream sserr;
    sserr << "duration overflows as nanoseconds: " << s;
    *error = sserr.str();
    return std::chrono::nanoseconds();
  }

  sum = add_rep_double(
    sum, days * 24.0 * 3.6e12, &overflows);
  if (overflows) {
    std::stringstream sserr;
    sserr << "duration overflows as nanoseconds: " << s;
    *error = sserr.str();
    return std::chrono::nanoseconds();
  }

  sum = add_rep_double(
    sum, weeks * 7.0 * 24.0 * 3.6e12, &overflows);
  if (overflows) {
    std::stringstream sserr;
    sserr << "duration overflows as nanoseconds: " << s;
    *error = sserr.str();
    return std::chrono::nanoseconds();
  }

  sum = add_rep_double(
    sum, months * 30.436875 * 24.0 * 3.6e12, &overflows);
  if (overflows) {
    std::stringstream sserr;
    sserr << "duration overflows as nanoseconds: " << s;
    *error = sserr.str();
    return std::chrono::nanoseconds();
  }

  sum = add_rep_double(
    sum, years * 365.2425 * 24.0 * 3.6e12, &overflows);
  if (overflows) {
    std::stringstream sserr;
    sserr << "duration overflows as nanoseconds: " << s;
    *error = sserr.str();
    return std::chrono::nanoseconds();
  }

  // sum is always positive, so the multiplication by -1 can not
  // overflow since |max rep_t| < |min rep_t|
  if (sign < 0) {
    sum = -sum;
  }

  return std::chrono::nanoseconds(sum);
}

/**
 * converts a JSON value type to a human-readable string representation.
 *
 * @param value_type to be converted
 * @return string representation of the JSON value type
 */
std::string value_type_to_string(Json::ValueType value_type) {
  switch (value_type) {
    case Json::ValueType::nullValue: return "null";
    case Json::ValueType::intValue: return "int";
    case Json::ValueType::uintValue: return "uint";
    case Json::ValueType::realValue: return "real";
    case Json::ValueType::stringValue: return "string";
    case Json::ValueType::booleanValue: return "bool";
    case Json::ValueType::arrayValue: return "array";
    case Json::ValueType::objectValue: return "object";
    default:
      std::stringstream ss;
      ss << "Unhandled value type in value_to_string: "
        << value_type;
      throw std::domain_error(ss.str());
  }
}

void some_graph_from(
    const Json::Value& value,
    std::string ref,
    SomeGraph* target,
    parse::Errors* errors) {
  if (errors == nullptr) {
    throw std::invalid_argument("Unexpected null errors");
  }

  if (!errors->empty()) {
    throw std::invalid_argument("Unexpected non-empty errors");
  }

  if (!value.isObject()) {
    constexpr auto expected_but_got(
      "Expected an object, but got: ");

    errors->add(
      ref,
      message(
        expected_but_got,
        strlen(expected_but_got),
        value_type_to_string(
          value.type())));
    return;
  }

  ////
  // Parse some_duration
  ////

  if (!value.isMember("some_duration")) {
    errors->add(
      ref,
      "Property is missing: some_duration");
  } else {
    const Json::Value& value_0 = value["some_duration"];
    if (!value_0.isString()) {
      constexpr auto expected_but_got(
        "Expected a string, but got: ");

      errors->add(
        std::string(ref)
          .append("/some_duration"),
        message(
          expected_but_got,
          strlen(expected_but_got),
          value_type_to_string(
            value_0.type())));
    } else {
      const std::string cast_0_str = value_0.asString();
      std::string error_0;
      std::chrono::nanoseconds cast_0 = duration_from_string(
        cast_0_str, &error_0);

      if (!error_0.empty()) {
        constexpr auto invalid_duration(
          "Invalid duration: ");

        errors->add(
          std::string(ref)
            .append("/some_duration"),
          message(
            invalid_duration,
            strlen(invalid_duration),
            error_0));
      } else {
        target->some_duration = cast_0;
      }
    }
  }
  if (errors->full()) {
    return;
  }
}

/**
 * serializes the duration to a string.
 *
 * @param[in] d duration to be serialized
 * @return duration as string
 */
std::string duration_to_string(const std::chrono::nanoseconds& d) {
  typedef std::chrono::nanoseconds::rep rep_t;

  const rep_t abscount = (d.count() < 0) ? -d.count() : d.count();
  if (abscount < 0) {
    std::stringstream sserr;
    sserr
      << "Computing the absolute number of nanoseconds "
        "in the duration underflowed: "
      << d.count();
    throw std::overflow_error(sserr.str());
  }

  const rep_t nanoseconds_in_day = 86400L*1000L*1000L*1000L;
  const rep_t days = abscount / nanoseconds_in_day;
  rep_t rest = abscount % nanoseconds_in_day;

  const rep_t nanoseconds_in_hour = 3600L*1000L*1000L*1000L;
  const rep_t hours = rest / nanoseconds_in_hour;
  rest = rest % nanoseconds_in_hour;

  const rep_t nanoseconds_in_minute = 60L*1000L*1000L*1000L;
  const rep_t minutes = rest / nanoseconds_in_minute;
  rest = rest % nanoseconds_in_minute;

  const rep_t nanoseconds_in_second = 1000L*1000L*1000L;
  const rep_t seconds = rest / nanoseconds_in_second;
  rest = rest % nanoseconds_in_second;

  const rep_t nanoseconds = rest;

  std::stringstream ss;
  if (d.count() < 0) {
    ss << "-";
  }

  ss << "P";

  if(days > 0) {
    ss << days << "D";
  }

  if(hours > 0 or minutes > 0 or
      seconds > 0 or nanoseconds > 0) {
    ss << "T";

    if(hours > 0) {
      ss << hours << "H";
    }

    if(minutes > 0) {
      ss << minutes << "M";
    }

    if(nanoseconds == 0) {
      if(seconds > 0) {
        ss << seconds << "S";
      }
    } else {
      std::stringstream ssnano;
      ssnano << std::setfill('0') << std::setw(9) << nanoseconds;
      const std::string nanos_str = ssnano.str();

      // Nag trailing zeros
      size_t i = nanos_str.size() - 1;
      for(; i >= 0; --i) {
        if (nanos_str.at(i) != '0') {
          break;
        }
      }

      ss << seconds << "." << nanos_str.substr(0, i + 1) << "S";
    }
  }

  return ss.str();
}

Json::Value serialize_some_graph(
    const SomeGraph& some_graph) {
  Json::Value some_graph_as_value;

  some_graph_as_value["some_duration"] = duration_to_string(some_graph.some_duration);

  return some_graph_as_value;
}

}  // namespace jsoncpp

}  // namespace graph
}  // namespace some

// File automatically generated by mapry. DO NOT EDIT OR APPEND!
