// File automatically generated by mapry. DO NOT EDIT OR APPEND!

#include "jsoncpp.h"
#include "parse.h"
#include "types.h"

#include <cmath>
#include <cstring>
#include <iomanip>
#include <limits>
#include <memory>
#include <regex>
#include <sstream>
#include <stdexcept>
#include <string>
#include <utility>

namespace book {
namespace address {

namespace jsoncpp {

/**
 * generates an error message.
 *
 * @param cc char array as the description part of the message
 * @param cc_size size of the char array
 * @param s string as the detail part of the message
 * @return concatenated string
 */
std::string message(const char* cc, size_t cc_size, std::string s) {
  std::string result;
  result.reserve(cc_size + s.size());
  result.append(cc, cc_size);
  result.append(s);
  return result;
}

namespace re {
const std::regex kDuration(
  "^(\\+|-)?P(((0|[1-9][0-9]*)(\\.[0-9]+)?)Y)?"
  "(((0|[1-9][0-9]*)(\\.[0-9]+)?)M)?"
  "(((0|[1-9][0-9]*)(\\.[0-9]+)?)W)?"
  "(((0|[1-9][0-9]*)(\\.[0-9]+)?)D)?"
  "(T"
  "(((0|[1-9][0-9]*)(\\.[0-9]+)?)H)?"
  "(((0|[1-9][0-9]*)(\\.[0-9]+)?)M)?"
  "(((0|[1-9][0-9]*)(\\.([0-9]+))?)S)?"
  ")?$");
}  // namespace re

/**
 * adds the left and the right and checks for the overflow.
 *
 * left and right are expected to be non-negative.
 *
 * @param[in] left summand
 * @param[in] right summand
 * @param[out] overflows true if the addition overflows
 * @return sum
 */
template <typename rep_t>
rep_t add_rep_double(rep_t left, double right, bool* overflows) {
  if (left < 0) {
    throw std::invalid_argument("Expected left >= 0");
  }

  if (right < 0) {
    throw std::invalid_argument("Expected right >= 0");
  }

  // 9223372036854775808 == 2^63, the first double that is
  // greater than max int64 (max int64 is 2^63 - 1).
  if (right >= 9223372036854775808.0) {
    *overflows = true;
    return 0;
  }

  const rep_t rightRep = right;

  if (rightRep > std::numeric_limits<rep_t>::max() - left) {
    *overflows = true;
    return 0;
  }

  return rightRep + left;
}

/**
 * parses the duration from a string.
 *
 *  Following STL chrono library, the following units are counted as:
 *   - years as 365.2425 days (the average length of a Gregorian year),
 *   - months as 30.436875 days (exactly 1/12 of years) and
 *   - weeks as 7 days.
 *
 * See https://en.cppreference.com/w/cpp/chrono/duration for details.
 *
 * @param[in] s string to parse
 * @param[out] error error message, if any
 * @return parsed duration
 */
std::chrono::nanoseconds duration_from_string(
    const std::string& s,
    std::string* error) {
  std::smatch mtch;
  const bool matched = std::regex_match(s, mtch, re::kDuration);

  if (not matched) {
    std::stringstream sserr;
    sserr << "failed to match the duration: " << s;
    *error = sserr.str();
    return std::chrono::nanoseconds();
  }

  typedef std::chrono::nanoseconds::rep rep_t;

  ////
  // Extract nanoseconds
  ////

  const std::string nanoseconds_str = mtch[31];
  rep_t nanoseconds;
  if (nanoseconds_str.size() == 0) {
    // No nanoseconds specified
    nanoseconds = 0;
  } else if(nanoseconds_str.size() <= 9) {
    size_t first_nonzero = 0;
    for (; first_nonzero < nanoseconds_str.size();
        ++first_nonzero) {
      if (nanoseconds_str[first_nonzero] >= '0' and
          nanoseconds_str[first_nonzero] <= '9') {
        break;
      }
    }

    if (first_nonzero == nanoseconds_str.size()) {
      // No non-zero numbers, all zeros behind the seconds comma
      nanoseconds = 0;
    } else {
      const rep_t fraction_as_integer(
        std::atol(&nanoseconds_str[first_nonzero]));

      const size_t order = 9 - nanoseconds_str.size();
      rep_t multiplier = 1;
      for (size_t i = 0; i < order; ++i) {
        multiplier *= 10;
      }

      nanoseconds = fraction_as_integer * multiplier;
    }
  } else {
    // Signal that the precision is lost
    std::stringstream sserr;
    sserr << "converting the duration to nanoseconds "
      "results in loss of precision: " << s;
    *error = sserr.str();
    return std::chrono::nanoseconds();
  }

  ////
  // Extract all the other interval counts
  ////

  const std::string sign_str = mtch[1];
  const rep_t sign = (sign_str.empty() or sign_str == "+") ? 1 : -1;

  const double years(
    (mtch[3].length() == 0) ? 0.0 : std::stod(mtch[3]));
  const double months(
    (mtch[7].length() == 0) ? 0.0 : std::stod(mtch[7]));
  const double weeks(
    (mtch[11].length() == 0) ? 0.0 : std::stod(mtch[11]));
  const double days(
    (mtch[15].length() == 0) ? 0.0 : std::stod(mtch[15]));
  const double hours(
    (mtch[20].length() == 0) ? 0.0 : std::stod(mtch[20]));
  const double minutes(
    (mtch[24].length() == 0) ? 0.0 : std::stod(mtch[24]));
  const rep_t seconds(
    (mtch[29].length() == 0) ? 0 : std::stol(mtch[29]));

  ////
  // Sum
  ////

  rep_t sum = nanoseconds;

  const rep_t max_seconds(
    std::numeric_limits<rep_t>::max() / (1000L * 1000L * 1000L));
  if (seconds > max_seconds) {
    std::stringstream sserr;
    sserr << "seconds in duration overflow as nanoseconds: " << s;
    *error = sserr.str();
    return std::chrono::nanoseconds();
  }

  const rep_t seconds_as_ns = seconds * 1000L * 1000L * 1000L;
  if (sum > std::numeric_limits<rep_t>::max() - seconds_as_ns) {
    std::stringstream sserr;
    sserr << "duration overflow as nanoseconds: " << s;
    *error = sserr.str();
    return std::chrono::nanoseconds();
  }
  sum += seconds_as_ns;

  bool overflows;

  sum = add_rep_double(
    sum, minutes * 6e10, &overflows);
  if (overflows) {
    std::stringstream sserr;
    sserr << "duration overflows as nanoseconds: " << s;
    *error = sserr.str();
    return std::chrono::nanoseconds();
  }

  sum = add_rep_double(
    sum, hours * 3.6e12, &overflows);
  if (overflows) {
    std::stringstream sserr;
    sserr << "duration overflows as nanoseconds: " << s;
    *error = sserr.str();
    return std::chrono::nanoseconds();
  }

  sum = add_rep_double(
    sum, days * 24.0 * 3.6e12, &overflows);
  if (overflows) {
    std::stringstream sserr;
    sserr << "duration overflows as nanoseconds: " << s;
    *error = sserr.str();
    return std::chrono::nanoseconds();
  }

  sum = add_rep_double(
    sum, weeks * 7.0 * 24.0 * 3.6e12, &overflows);
  if (overflows) {
    std::stringstream sserr;
    sserr << "duration overflows as nanoseconds: " << s;
    *error = sserr.str();
    return std::chrono::nanoseconds();
  }

  sum = add_rep_double(
    sum, months * 30.436875 * 24.0 * 3.6e12, &overflows);
  if (overflows) {
    std::stringstream sserr;
    sserr << "duration overflows as nanoseconds: " << s;
    *error = sserr.str();
    return std::chrono::nanoseconds();
  }

  sum = add_rep_double(
    sum, years * 365.2425 * 24.0 * 3.6e12, &overflows);
  if (overflows) {
    std::stringstream sserr;
    sserr << "duration overflows as nanoseconds: " << s;
    *error = sserr.str();
    return std::chrono::nanoseconds();
  }

  // sum is always positive, so the multiplication by -1 can not
  // overflow since |max rep_t| < |min rep_t|
  if (sign < 0) {
    sum = -sum;
  }

  return std::chrono::nanoseconds(sum);
}

/**
 * converts a JSON value type to a human-readable string representation.
 *
 * @param value_type to be converted
 * @return string representation of the JSON value type
 */
std::string value_type_to_string(Json::ValueType value_type) {
  switch (value_type) {
    case Json::ValueType::nullValue: return "null";
    case Json::ValueType::intValue: return "int";
    case Json::ValueType::uintValue: return "uint";
    case Json::ValueType::realValue: return "real";
    case Json::ValueType::stringValue: return "string";
    case Json::ValueType::booleanValue: return "bool";
    case Json::ValueType::arrayValue: return "array";
    case Json::ValueType::objectValue: return "object";
    default:
      std::stringstream ss;
      ss << "Unhandled value type in value_to_string: "
        << value_type;
      throw std::domain_error(ss.str());
  }
}

void pipeline_from(
    const Json::Value& value,
    std::string ref,
    Pipeline* target,
    parse::Errors* errors) {
  if (errors == nullptr) {
    throw std::invalid_argument("Unexpected null errors");
  }

  if (not errors->empty()) {
    throw std::invalid_argument("Unexpected non-empty errors");
  }

  if (not value.isObject()) {
    constexpr auto expected_but_got(
      "Expected an object, but got: ");

    errors->add(
      ref,
      message(
        expected_but_got,
        strlen(expected_but_got),
        value_type_to_string(
          value.type())));
    return;
  }

  ////
  // Pre-allocate persons
  ////

  std::string persons_ref;
  persons_ref.reserve(ref.size() + 8);
  persons_ref += ref;
  persons_ref += "/persons";

  if (value.isMember("persons")) {
    const Json::Value& obj = value["persons"];
    if (not obj.isObject()) {
      constexpr auto expected_but_got(
        "Expected an object, but got: ");

      errors->add(
        persons_ref,
        message(
          expected_but_got,
          strlen(expected_but_got),
          value_type_to_string(
            obj.type())));
    } else {
      for (Json::ValueConstIterator it = obj.begin();
          it != obj.end(); ++it) {
                auto instance = std::make_unique<Person>();
        instance->id = it.name();
        target->persons[it.name()] = std::move(instance);

      }
    }
  }

  // Pre-allocating class instances is critical.
  // If the pre-allocation failed, we can not continue to parse the instances.
  if (not errors->empty()) {
    return;
  }

  // Keep the prefix fixed in this buffer so that
  // it is copied as little as possible
  std::string instance_ref;

  ////
  // Parse persons
  ////

  // clear() does not shrink the reserved memory,
  // see https://en.cppreference.com/w/cpp/string/basic_string/clear
  instance_ref.clear();
  instance_ref += persons_ref;
  instance_ref += '/';

  if (value.isMember("persons")) {
    const Json::Value& obj = value["persons"];

    for (Json::ValueConstIterator it = obj.begin(); it != obj.end(); ++it) {
      instance_ref.reserve(
        persons_ref.size() + 1 + it.name().size());
      instance_ref.resize(
        persons_ref.size() + 1);
      instance_ref.append(
        it.name());

      Person* instance(
        target->persons.at(it.name()).get());
      person_from(
        *it,
        target->persons,
        instance_ref,
        instance,
        errors);

      if (errors->full()) {
        break;
      }
    }
  }
  if (errors->full()) {
    return;
  }

  ////
  // Parse maintainer
  ////

  if (not value.isMember("maintainer")) {
    errors->add(
      ref,
      "Property is missing: maintainer");
  } else {
    const Json::Value& value_0 = value["maintainer"];
    if (not value_0.isString()) {
      constexpr auto expected_but_got(
        "Expected a string, but got: ");

      errors->add(
        std::string(ref)
          .append("/maintainer"),
        message(
          expected_but_got,
          strlen(expected_but_got),
          value_type_to_string(
            value_0.type())));
    } else {
      const std::string& cast_0 = value_0.asString();
      if (target->persons.count(cast_0) == 0) {
        constexpr auto reference_not_found(
          "Reference to an instance of class "
          "Person"
          " not found: ");

        errors->add(
          std::string(ref)
            .append("/maintainer"),
          message(
            reference_not_found,
            strlen(reference_not_found),
            cast_0));
      } else {
        target->maintainer = target->persons.at(cast_0).get();
      }
    }
  }
  if (errors->full()) {
    return;
  }
}

/**
 * serializes the date/time/datetime to a string.
 *
 * @param[in] t time structure
 * @param[in] fmt format
 * @return time structure serialized to a string according to the format
 */
std::string tm_to_string(const struct tm& t, const char* fmt) {{
  if(fmt == nullptr or fmt[0] == '\0') {
    return "";
  }

  const size_t fmt_size = strlen(fmt);

  std::string buf;
  buf.resize(fmt_size * 4);
  int len = strftime(&buf[0], buf.size(), fmt, &t);

  while(len == 0) {{
    buf.resize(buf.size() * 2);
    int len = strftime(&buf[0], buf.size(), fmt, &t);
  }}
  buf.resize(len);
  return buf;
}}

/**
 * serializes the duration to a string.
 *
 * @param[in] d duration to be serialized
 * @return duration as string
 */
std::string duration_to_string(const std::chrono::nanoseconds& d) {
  typedef std::chrono::nanoseconds::rep rep_t;

  const rep_t abscount = (d.count() < 0) ? -d.count() : d.count();
  if (abscount < 0) {
    std::stringstream sserr;
    sserr
      << "Computing the absolute number of nanoseconds "
        "in the duration underflowed: "
      << d.count();
    throw std::overflow_error(sserr.str());
  }

  const rep_t nanoseconds_in_day = 86400L*1000L*1000L*1000L;
  const rep_t days = abscount / nanoseconds_in_day;
  rep_t rest = abscount % nanoseconds_in_day;

  const rep_t nanoseconds_in_hour = 3600L*1000L*1000L*1000L;
  const rep_t hours = rest / nanoseconds_in_hour;
  rest = rest % nanoseconds_in_hour;

  const rep_t nanoseconds_in_minute = 60L*1000L*1000L*1000L;
  const rep_t minutes = rest / nanoseconds_in_minute;
  rest = rest % nanoseconds_in_minute;

  const rep_t nanoseconds_in_second = 1000L*1000L*1000L;
  const rep_t seconds = rest / nanoseconds_in_second;
  rest = rest % nanoseconds_in_second;

  const rep_t nanoseconds = rest;

  std::stringstream ss;
  if (d.count() < 0) {
    ss << "-";
  }

  ss << "P";

  if(days > 0) {
    ss << days << "D";
  }

  if(hours > 0 or minutes > 0 or
      seconds > 0 or nanoseconds > 0) {
    ss << "T";

    if(hours > 0) {
      ss << hours << "H";
    }

    if(minutes > 0) {
      ss << minutes << "M";
    }

    if(nanoseconds == 0) {
      if(seconds > 0) {
        ss << seconds << "S";
      }
    } else {
      std::stringstream ssnano;
      ssnano << std::setfill('0') << std::setw(9) << nanoseconds;
      const std::string nanos_str = ssnano.str();

      // Nag trailing zeros
      size_t i = nanos_str.size() - 1;
      for(; i >= 0; --i) {
        if (nanos_str.at(i) != '0') {
          break;
        }
      }

      ss << seconds << "." << nanos_str.substr(0, i + 1) << "S";
    }
  }

  return ss.str();
}

void person_from(
    const Json::Value& value,
    const std::map<std::string, std::unique_ptr<Person>>& persons_registry,
    std::string ref,
    Person* target,
    parse::Errors* errors) {
  if (not value.isObject()) {
    constexpr auto expected_but_got(
      "Expected an object, but got: ");

    errors->add(
      ref,
      message(
        expected_but_got,
        strlen(expected_but_got),
        value_type_to_string(
          value.type())));
    return;
  }

  ////
  // Parse full_name
  ////

  if (not value.isMember("full_name")) {
    errors->add(
      ref,
      "Property is missing: full_name");
  } else {
    const Json::Value& value_0 = value["full_name"];
    if (not value_0.isString()) {
      constexpr auto expected_but_got(
        "Expected a string, but got: ");

      errors->add(
        std::string(ref)
          .append("/full_name"),
        message(
          expected_but_got,
          strlen(expected_but_got),
          value_type_to_string(
            value_0.type())));
    } else {
      target->full_name = value_0.asString();
    }
  }
  if (errors->full()) {
    return;
  }

  ////
  // Parse address
  ////

  if (not value.isMember("address")) {
    errors->add(
      ref,
      "Property is missing: address");
  } else {
    const Json::Value& value_1 = value["address"];
    address_from(
      value_1,
      std::string(ref)
        .append("/address"),
      &target->address,
      errors);
  }
  if (errors->full()) {
    return;
  }

  ////
  // Parse picture
  ////

  if (value.isMember("picture")) {
    const Json::Value& value_2 = value["picture"];
    if (not value_2.isString()) {
      constexpr auto expected_but_got(
        "Expected a string, but got: ");

      errors->add(
        std::string(ref)
          .append("/picture"),
        message(
          expected_but_got,
          strlen(expected_but_got),
          value_type_to_string(
            value_2.type())));
    } else {
      const static std::regex regex(
        R"v0g0n(^/images/.*$)v0g0n");
      const std::string cast_2 = value_2.asString();
      bool ok_2 = true;

      if (not std::regex_match(cast_2, regex)) {
        constexpr auto expected_but_got(
          "Expected to match "
          "^/images/.*$"
          ", but got: ");

        errors->add(
          std::string(ref)
            .append("/picture"),
          message(
            expected_but_got,
            strlen(expected_but_got),
            cast_2));
        ok_2 = false;
      }

      if (ok_2) {
          target->picture = boost::filesystem::path(
          value_2.asString());

      }
    }
  }
  if (errors->full()) {
    return;
  }

  ////
  // Parse birthday
  ////

  if (not value.isMember("birthday")) {
    errors->add(
      ref,
      "Property is missing: birthday");
  } else {
    const Json::Value& value_3 = value["birthday"];
    if (not value_3.isString()) {
      constexpr auto expected_but_got(
        "Expected a string, but got: ");

      errors->add(
        std::string(ref)
          .append("/birthday"),
        message(
          expected_but_got,
          strlen(expected_but_got),
          value_type_to_string(
            value_3.type())));
    } else {
      const std::string cast_3 = value_3.asString();
      struct tm tm_3 = tm{0};
      char* ret_3 = strptime(
        cast_3.c_str(),
        "%Y-%m-%d",
        &tm_3);

      if (ret_3 == nullptr or *ret_3 != '\0') {
        constexpr auto expected_but_got(
          "Expected to strptime "
          "%Y-%m-%d"
          ", but got: ");

        errors->add(
          std::string(ref)
            .append("/birthday"),
          message(
            expected_but_got,
            strlen(expected_but_got),
            cast_3));
      } else {
        target->birthday = tm_3;
      }
    }
  }
  if (errors->full()) {
    return;
  }

  ////
  // Parse last_modified
  ////

  if (not value.isMember("last_modified")) {
    errors->add(
      ref,
      "Property is missing: last_modified");
  } else {
    const Json::Value& value_4 = value["last_modified"];
    if (not value_4.isString()) {
      constexpr auto expected_but_got(
        "Expected a string, but got: ");

      errors->add(
        std::string(ref)
          .append("/last_modified"),
        message(
          expected_but_got,
          strlen(expected_but_got),
          value_type_to_string(
            value_4.type())));
    } else {
      const std::string cast_4 = value_4.asString();
      struct tm tm_4 = tm{0};
      char* ret_4 = strptime(
        cast_4.c_str(),
        "%Y-%m-%dT%H:%M:%SZ",
        &tm_4);

      if (ret_4 == nullptr or *ret_4 != '\0') {
        constexpr auto expected_but_got(
          "Expected to strptime "
          "%Y-%m-%dT%H:%M:%SZ"
          ", but got: ");

        errors->add(
          std::string(ref)
            .append("/last_modified"),
          message(
            expected_but_got,
            strlen(expected_but_got),
            cast_4));
      } else {
        target->last_modified = tm_4;
      }
    }
  }
  if (errors->full()) {
    return;
  }

  ////
  // Parse contact_period
  ////

  if (not value.isMember("contact_period")) {
    errors->add(
      ref,
      "Property is missing: contact_period");
  } else {
    const Json::Value& value_5 = value["contact_period"];
    if (not value_5.isString()) {
      constexpr auto expected_but_got(
        "Expected a string, but got: ");

      errors->add(
        std::string(ref)
          .append("/contact_period"),
        message(
          expected_but_got,
          strlen(expected_but_got),
          value_type_to_string(
            value_5.type())));
    } else {
      const std::string cast_5_str = value_5.asString();
      std::string error_5;
      std::chrono::nanoseconds cast_5 = duration_from_string(
        cast_5_str, &error_5);

      if (not error_5.empty()) {
        constexpr auto invalid_duration(
          "Invalid duration: ");

        errors->add(
          std::string(ref)
            .append("/contact_period"),
          message(
            invalid_duration,
            strlen(invalid_duration),
            error_5));
      } else {
        target->contact_period = cast_5;
      }
    }
  }
  if (errors->full()) {
    return;
  }

  ////
  // Parse friends
  ////

  if (not value.isMember("friends")) {
    errors->add(
      ref,
      "Property is missing: friends");
  } else {
    const Json::Value& value_6 = value["friends"];
    if (not value_6.isObject()) {
      constexpr auto expected_but_got(
        "Expected an object, but got: ");

      errors->add(
        std::string(ref)
          .append("/friends"),
        message(
          expected_but_got,
          strlen(expected_but_got),
          value_type_to_string(
            value_6.type())));
    } else {
      std::map<std::string, Person*>& target_6 = target->friends;
      for (Json::ValueConstIterator it_6 = value_6.begin(); it_6 != value_6.end(); ++it_6) {
        const Json::Value& value_7 = *it_6;
        if (not value_7.isString()) {
          constexpr auto expected_but_got(
            "Expected a string, but got: ");

          errors->add(
            std::string(ref)
              .append("/friends")
              .append("/")
              .append(it_6.name()),
            message(
              expected_but_got,
              strlen(expected_but_got),
              value_type_to_string(
                value_7.type())));
        } else {
          const std::string& cast_7 = value_7.asString();
          if (persons_registry.count(cast_7) == 0) {
            constexpr auto reference_not_found(
              "Reference to an instance of class "
              "Person"
              " not found: ");

            errors->add(
              std::string(ref)
                .append("/friends")
                .append("/")
                .append(it_6.name()),
              message(
                reference_not_found,
                strlen(reference_not_found),
                cast_7));
          } else {
            target_6[it_6.name()] = persons_registry.at(cast_7).get();
          }
        }

        if (errors->full()) {
          break;
        }
      }
    }
  }
  if (errors->full()) {
    return;
  }

  ////
  // Parse active
  ////

  if (not value.isMember("active")) {
    errors->add(
      ref,
      "Property is missing: active");
  } else {
    const Json::Value& value_8 = value["active"];
    if (not value_8.isBool()) {
      constexpr auto expected_but_got(
        "Expected a bool, but got: ");

      errors->add(
        std::string(ref)
          .append("/active"),
        message(
          expected_but_got,
          strlen(expected_but_got),
          value_type_to_string(
            value_8.type())));
    } else {
      target->active = value_8.asBool();
    }
  }
  if (errors->full()) {
    return;
  }

  ////
  // Parse height
  ////

  if (not value.isMember("height")) {
    errors->add(
      ref,
      "Property is missing: height");
  } else {
    const Json::Value& value_9 = value["height"];
    if (not value_9.isInt64()) {
      constexpr auto expected_but_got(
        "Expected an int64, but got: ");

      errors->add(
        std::string(ref)
          .append("/height"),
        message(
          expected_but_got,
          strlen(expected_but_got),
          value_type_to_string(
            value_9.type())));
    } else {
      const auto cast_9 = value_9.asInt64();
      bool ok_9 = true;

      if (not (cast_9 >= 0)) {
        constexpr auto expected_but_got(
          "Expected "
          ">= 0"
          ", but got: ");

        errors->add(
          std::string(ref)
            .append("/height"),
          message(
            expected_but_got,
            strlen(expected_but_got),
            std::to_string(cast_9)));
        ok_9 = false;
      }

      if (not (cast_9 <= 300)) {
        constexpr auto expected_but_got(
          "Expected "
          "<= 300"
          ", but got: ");

        errors->add(
          std::string(ref)
            .append("/height"),
          message(
            expected_but_got,
            strlen(expected_but_got),
            std::to_string(cast_9)));
        ok_9 = false;
      }

      if (ok_9) {
        target->height = cast_9;
      }
    }
  }
  if (errors->full()) {
    return;
  }

  ////
  // Parse fee
  ////

  if (not value.isMember("fee")) {
    errors->add(
      ref,
      "Property is missing: fee");
  } else {
    const Json::Value& value_10 = value["fee"];
    if (not value_10.isDouble()) {
      constexpr auto expected_but_got(
        "Expected a double, but got: ");

      errors->add(
        std::string(ref)
          .append("/fee"),
        message(
          expected_but_got,
          strlen(expected_but_got),
          value_type_to_string(
            value_10.type())));
    } else {
      const auto cast_10 = value_10.asDouble();
      bool ok_10 = true;

      if (not (cast_10 >= 0)) {
        constexpr auto expected_but_got(
          "Expected "
          ">= 0.000000"
          ", but got: ");

        errors->add(
          std::string(ref)
            .append("/fee"),
          message(
            expected_but_got,
            strlen(expected_but_got),
            std::to_string(cast_10)));
        ok_10 = false;
      }

      if (ok_10) {
        target->fee = cast_10;
      }
    }
  }
  if (errors->full()) {
    return;
  }
}

void address_from(
    const Json::Value& value,
    std::string ref,
    Address* target,
    parse::Errors* errors) {
  if (not value.isObject()) {
    constexpr auto expected_but_got(
      "Expected an object, but got: ");

    errors->add(
      ref,
      message(
        expected_but_got,
        strlen(expected_but_got),
        value_type_to_string(
          value.type())));
    return;
  }

  ////
  // Parse text
  ////

  if (not value.isMember("text")) {
    errors->add(
      ref,
      "Property is missing: text");
  } else {
    const Json::Value& value_0 = value["text"];
    if (not value_0.isString()) {
      constexpr auto expected_but_got(
        "Expected a string, but got: ");

      errors->add(
        std::string(ref)
          .append("/text"),
        message(
          expected_but_got,
          strlen(expected_but_got),
          value_type_to_string(
            value_0.type())));
    } else {
      target->text = value_0.asString();
    }
  }
  if (errors->full()) {
    return;
  }

  ////
  // Parse time_zone
  ////

  if (not value.isMember("time_zone")) {
    errors->add(
      ref,
      "Property is missing: time_zone");
  } else {
    const Json::Value& value_1 = value["time_zone"];
    if (not value_1.isString()) {
      constexpr auto expected_but_got(
        "Expected a string, but got: ");

      errors->add(
        std::string(ref)
          .append("/time_zone"),
        message(
          expected_but_got,
          strlen(expected_but_got),
          value_type_to_string(
            value_1.type())));
    } else {
      target->time_zone = value_1.asString();
    }
  }
  if (errors->full()) {
    return;
  }
}

Json::Value serialize_person(
    const Person& person) {
  Json::Value person_as_value;

  person_as_value["full_name"] = person.full_name;

  person_as_value["address"] = serialize_address(person.address);

  if (person.picture) {
    person_as_value["picture"] = (*person.picture).string();
  }

  person_as_value["birthday"] = tm_to_string(
    person.birthday,
    "%Y-%m-%d");

  person_as_value["last_modified"] = tm_to_string(
    person.last_modified,
    "%Y-%m-%dT%H:%M:%SZ");

  person_as_value["contact_period"] = duration_to_string(person.contact_period);

  Json::Value target_0(Json::objectValue);
  const auto& map_0 = person.friends;
  for (const auto& kv_0 : map_0) {
    target_0[kv_0.first] = kv_0.second->id;
  }
  person_as_value["friends"] = std::move(target_0);

  person_as_value["active"] = person.active;

  person_as_value["height"] = person.height;

  person_as_value["fee"] = person.fee;

  return person_as_value;
}

Json::Value serialize_address(
    const Address& address) {
  Json::Value address_as_value;

  address_as_value["text"] = address.text;

  address_as_value["time_zone"] = address.time_zone;

  return address_as_value;
}

Json::Value serialize_pipeline(
    const Pipeline& pipeline) {
  Json::Value pipeline_as_value;

  pipeline_as_value["maintainer"] = pipeline.maintainer->id;

  if (not pipeline.persons.empty()) {
    Json::Value persons_as_value;
    for (const auto& kv : pipeline.persons) {
      const std::string& id = kv.first;
      const Person* instance = kv.second.get();

      if (id != instance->id) {
        constexpr auto expected(
          "Expected the class instance of "
          "Person"
          "to have the ID ");
        constexpr auto but_got(", but got: ");

        std::string msg;
        msg.reserve(
          strlen(expected) + id.size() +
          strlen(but_got) + instance->id.size());
        msg += expected;
        msg += id;
        msg += but_got;
        msg += instance->id;

        throw std::invalid_argument(msg);
      }

      persons_as_value[instance->id] = serialize_person(*instance);
    }
    pipeline_as_value["persons"] = persons_as_value;
  }

  return pipeline_as_value;
}

}  // namespace jsoncpp

}  // namespace address
}  // namespace book

// File automatically generated by mapry. DO NOT EDIT OR APPEND!
