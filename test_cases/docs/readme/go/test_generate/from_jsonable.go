package address

// File automatically generated by mapry. DO NOT EDIT OR APPEND!

import (
	"fmt"
	"math"
	"regexp"
	"strconv"
	"strings"
	"time"
)

var durationRe = regexp.MustCompile(
	`^(-|\+)?P`+
	`(((0|[1-9][0-9]*)(\.[0-9]+)?)Y)?`+
	`(((0|[1-9][0-9]*)(\.[0-9]+)?)M)?`+
	`(((0|[1-9][0-9]*)(\.[0-9]+)?)W)?`+
	`(((0|[1-9][0-9]*)(\.[0-9]+)?)D)?`+
	`(T`+
	`(((0|[1-9][0-9]*)(\.[0-9]+)?)H)?`+
	`(((0|[1-9][0-9]*)(\.[0-9]+)?)M)?`+
	`(((0|[1-9][0-9]*)(\.([0-9]+))?)S)?`+
	`)?$`)

// addDuration adds right nanoseconds to the left duration.
//
// addDurationInt64 requires:
//  * left >= 0
//  * right >= 0
func addDuration(
	left time.Duration,
	right float64) (result time.Duration, overflow bool) {

	if !(left >= 0) {
		panic("Expected left >= 0")
	}

	if !(right >= 0) {
		panic("Expected right >= 0")
	}

	// 9223372036854775808.0 == 2^63 is the first float > MaxInt64.
	if right >= 9223372036854775808.0 {
		overflow = true
		return
	}

	rightAsNs := time.Duration(right)
	if rightAsNs > math.MaxInt64 - left {
		overflow = true
		return
	}

	result = left + rightAsNs
	return
}

// durationFromString parses the duration as ISO 8601 format.
//
// Following C++ chrono library, the following units are counted as:
//  * years as 365.2425 days (the average length of a Gregorian year),
//  * months as 30.436875 days (exactly 1/12 of years) and
//  * weeks as 7 days.
//
// Since time.Duration is measured in nanoseconds, beware of overflow
// issues due to finite representation of integers.
func durationFromString(s string) (d time.Duration, err error) {
	m := durationRe.FindStringSubmatch(s)

	if len(m) == 0 {
		err = fmt.Errorf("failed to match the duration pattern")
		return
	}

	////
	// Interprete
	////

	var years, months, weeks, days, hours, minutes float64
	var seconds, nanoseconds int64

	sign := int64(1)
	if len(m[1]) > 0 && m[1][0] == '-' {
		sign = -1
	}

	if len(m[3]) > 0 {
		years, err = strconv.ParseFloat(m[3], 64)
		if err != nil {
			err = fmt.Errorf("failed to parse the years: %s", err.Error())
			return
		}
	}

	if len(m[7]) > 0 {
		months, err = strconv.ParseFloat(m[7], 64)
		if err != nil {
			err = fmt.Errorf("failed to parse the months: %s", err.Error())
			return
		}
	}

	if len(m[11]) > 0 {
		weeks, err = strconv.ParseFloat(m[11], 64)
		if err != nil {
			err = fmt.Errorf("failed to parse the weeks: %s", err.Error())
			return
		}
	}

	if len(m[15]) > 0 {
		days, err = strconv.ParseFloat(m[15], 64)
		if err != nil {
			err = fmt.Errorf("failed to parse the days: %s", err.Error())
			return
		}
	}

	if len(m[20]) > 0 {
		hours, err = strconv.ParseFloat(m[20], 64)
		if err != nil {
			err = fmt.Errorf("failed to parse the hours: %s", err.Error())
			return
		}
	}

	if len(m[24]) > 0 {
		minutes, err = strconv.ParseFloat(m[24], 64)
		if err != nil {
			err = fmt.Errorf("failed to parse the minutes: %s", err.Error())
			return
		}
	}

	if len(m[29]) > 0 {
		seconds, err = strconv.ParseInt(m[29], 10, 64)
		if err != nil {
			err = fmt.Errorf("failed to parse the seconds: %s", err.Error())
			return
		}
	}

	switch {
	case len(m[31]) == 0:
		// pass
	case len(m[31]) <= 9:
		trimmed := strings.TrimLeft(m[31], "0")
		if len(trimmed) > 0 {
			nanoseconds, err = strconv.ParseInt(trimmed, 10, 64)
			if err != nil {
				err = fmt.Errorf(
					"failed to parse nanoseconds from: %s",
					err.Error())
			}

			order := 9 - len(m[31])
			for i := 0; i < order; i++ {
				nanoseconds *= 10
			}
		}
	default:
		err = fmt.Errorf(
			"precision only up to nanoseconds supported")
		return
	}

	////
	// Sum
	////

	d = time.Duration(nanoseconds)

	if seconds > (math.MaxInt64 / (1000 * 1000 * 1000)) {
		err = fmt.Errorf("seconds overflow in nanoseconds")
		return
	}

	secondsAsNs := time.Duration(seconds * 1000 * 1000 * 1000)
	if secondsAsNs > math.MaxInt64 - d {
		err = fmt.Errorf(
			"overflow in nanoseconds")
		return
	}
	d += secondsAsNs

	var overflow bool
	d, overflow = addDuration(d, minutes * 6e10)
	if overflow {
		err = fmt.Errorf("overflow in nanoseconds")
		return
	}

	d, overflow = addDuration(d, hours * 3.6e12)
	if overflow {
		err = fmt.Errorf("overflow in nanoseconds")
		return
	}

	d, overflow = addDuration(d, days * 24.0 * 3.6e12)
	if overflow {
		err = fmt.Errorf("overflow in nanoseconds")
		return
	}

	d, overflow = addDuration(d, weeks * 7.0 * 24.0 * 3.6e12)
	if overflow {
		err = fmt.Errorf("overflow in nanoseconds")
		return
	}

	d, overflow = addDuration(d, months * 30.436875 * 24.0 * 3.6e12)
	if overflow {
		err = fmt.Errorf("overflow in nanoseconds")
		return
	}

	d, overflow = addDuration(d, years * 365.2425 * 24.0 * 3.6e12)
	if overflow {
		err = fmt.Errorf("overflow in nanoseconds")
		return
	}

	// d is always positive, so the multiplication by -1 can not
	// overflow since |math.MaxInt64| < |math.MinInt64|
	d *= time.Duration(sign);

	return
}

var pattern0 = regexp.MustCompile(
	`^/images/.*$`)

// PersonFromJSONable parses Person from a JSONable value.
//
// If there are any errors, the state of the target is undefined.
//
// PersonFromJSONable requires:
//  * target != nil
//  * errors != nil
//  * errors.Empty()
func PersonFromJSONable(
	value interface{},
	id string,
	personsRegistry map[string]*Person,
	ref string,
	target *Person,
	errors *Errors) {

	if target == nil {
		panic("unexpected nil target")
	}

	if errors == nil {
		panic("unexpected nil errors")
	}

	if !errors.Empty() {
		panic("unexpected non-empty errors")
	}

	cast, ok := value.(map[string]interface{})
	if !ok {
		errors.Add(
			ref,
			fmt.Sprintf(
				"expected a map[string]interface{}, but got: %T",
				value))
		return
	}

	target.ID = id

	////
	// Parse FullName
	////

	value0, ok0 := cast[
		"full_name"]

	if !ok0 {
		errors.Add(
			ref,
			"property is missing: full_name")
	} else {
		cast1, ok1 := value0.(string)
		if !ok1 {
			errors.Add(
				strings.Join(
					[]string{
						ref, "full_name"},
					"/"),
				fmt.Sprintf(
					"expected a string, but got: %T",
					value0))
		} else {
			target.FullName = cast1
		}
	}

	if errors.Full() {
		return
	}

	////
	// Parse Address
	////

	value2, ok2 := cast[
		"address"]

	if !ok2 {
		errors.Add(
			ref,
			"property is missing: address")
	} else {
		AddressFromJSONable(
			value2,
			strings.Join(
				[]string{
					ref, "address"},
				"/"),
			&(target.Address),
			errors)
	}

	if errors.Full() {
		return
	}

	////
	// Parse Picture
	////

	value4, ok4 := cast[
		"picture"]

	if ok4 {
		var target4 string
		cast5, ok5 := value4.(string)
		if !ok5 {
			errors.Add(
				strings.Join(
					[]string{
						ref, "picture"},
					"/"),
				fmt.Sprintf(
					"expected a string, but got: %T",
					value4))
		} else {
			if !pattern0.MatchString(cast5) {
				errors.Add(
					strings.Join(
						[]string{
							ref, "picture"},
						"/"),
					fmt.Sprintf(
						"expected to match ^/images/.*$, but got: %s",
						cast5))
			} else {
				target4 = cast5
			}
		}

		target.Picture = &target4
	}

	if errors.Full() {
		return
	}

	////
	// Parse Birthday
	////

	value6, ok6 := cast[
		"birthday"]

	if !ok6 {
		errors.Add(
			ref,
			"property is missing: birthday")
	} else {
		cast7, ok7 := value6.(string)
		if !ok7 {
			errors.Add(
				strings.Join(
					[]string{
						ref, "birthday"},
					"/"),
				fmt.Sprintf(
					"expected a string, but got: %T",
					value6))
		} else {
			target7, err7 := time.Parse(
				"2006-01-02",
				cast7)
			if err7 != nil {
				errors.Add(
					strings.Join(
						[]string{
							ref, "birthday"},
						"/"),
					fmt.Sprintf(
						"expected layout 2006-01-02, got: %s",
						cast7))
			} else {
				target.Birthday = target7
			}
		}
	}

	if errors.Full() {
		return
	}

	////
	// Parse LastModified
	////

	value8, ok8 := cast[
		"last_modified"]

	if !ok8 {
		errors.Add(
			ref,
			"property is missing: last_modified")
	} else {
		cast9, ok9 := value8.(string)
		if !ok9 {
			errors.Add(
				strings.Join(
					[]string{
						ref, "last_modified"},
					"/"),
				fmt.Sprintf(
					"expected a string, but got: %T",
					value8))
		} else {
			target9, err9 := time.Parse(
				"2006-01-02T15:04:05Z",
				cast9)
			if err9 != nil {
				errors.Add(
					strings.Join(
						[]string{
							ref, "last_modified"},
						"/"),
					fmt.Sprintf(
						"expected layout 2006-01-02T15:04:05Z, got: %s",
						cast9))
			} else {
				target.LastModified = target9
			}
		}
	}

	if errors.Full() {
		return
	}

	////
	// Parse ContactPeriod
	////

	value10, ok10 := cast[
		"contact_period"]

	if !ok10 {
		errors.Add(
			ref,
			"property is missing: contact_period")
	} else {
		cast11, ok11 := value10.(string)
		if !ok11 {
			errors.Add(
				strings.Join(
					[]string{
						ref, "contact_period"},
					"/"),
				fmt.Sprintf(
					"expected a string, but got: %T",
					value10))
		} else {
			target11, err11 := durationFromString(cast11)
			if err11 != nil {
				errors.Add(
					strings.Join(
						[]string{
							ref, "contact_period"},
						"/"),
					fmt.Sprintf(
						"failed to parse duration from %#v: %s",
						cast11,
						err11.Error()))
			} else {
				target.ContactPeriod = target11
			}
		}
	}

	if errors.Full() {
		return
	}

	////
	// Parse Friends
	////

	value12, ok12 := cast[
		"friends"]

	if !ok12 {
		errors.Add(
			ref,
			"property is missing: friends")
	} else {
		cast13, ok13 := value12.(map[string]interface{})
		if !ok13 {
			errors.Add(
				strings.Join(
					[]string{
						ref, "friends"},
					"/"),
				fmt.Sprintf(
					"expected a map[string]interface{}, but got: %T",
					value12))
		} else {
			target13 := make(map[string]*Person)
			for k13 := range cast13 {
				cast14, ok14 := (cast13[k13]).(string)
				if !ok14 {
					errors.Add(
						strings.Join(
							[]string{
								ref, "friends", k13},
							"/"),
						fmt.Sprintf(
							"expected a string, but got: %T",
							cast13[k13]))
				} else {
					target14, ok14 := personsRegistry[cast14]
					if !ok14 {
						errors.Add(
							strings.Join(
								[]string{
									ref, "friends", k13},
								"/"),
							fmt.Sprintf(
								"reference to an instance of class Person not found: %s",
								cast13[k13]))
					} else {
						target13[k13] = target14
					}
				}

				if errors.Full() {
					break;
				}
			}

			target.Friends = target13
		}
	}

	if errors.Full() {
		return
	}

	////
	// Parse Active
	////

	value15, ok15 := cast[
		"active"]

	if !ok15 {
		errors.Add(
			ref,
			"property is missing: active")
	} else {
		cast16, ok16 := value15.(bool)
		if !ok16 {
			errors.Add(
				strings.Join(
					[]string{
						ref, "active"},
					"/"),
				fmt.Sprintf(
					"expected a bool, but got: %T",
					value15))
		} else {
			target.Active = cast16
		}
	}

	if errors.Full() {
		return
	}

	////
	// Parse Height
	////

	value17, ok17 := cast[
		"height"]

	if !ok17 {
		errors.Add(
			ref,
			"property is missing: height")
	} else {
		fcast18, ok18 := value17.(float64)
		if !ok18 {
			errors.Add(
				strings.Join(
					[]string{
						ref, "height"},
					"/"),
				fmt.Sprintf(
					"expected a float64, but got: %T",
					value17))
		} else if fcast18 != math.Trunc(fcast18) {
			errors.Add(
				strings.Join(
					[]string{
						ref, "height"},
					"/"),
				fmt.Sprintf(
					"expected a whole number, but got: %f",
					fcast18))
		// 9223372036854775808.0 == 2^63 is the first float > MaxInt64.
		// -9223372036854775808.0 == -(2^63) is the last float >= MinInt64.
		} else if fcast18 >= 9223372036854775808.0 ||
			fcast18 < -9223372036854775808.0 {

			errors.Add(
				strings.Join(
					[]string{
						ref, "height"},
					"/"),
				fmt.Sprintf(
					"expected the value to fit into int64, but got an overflow: %f",
					fcast18))
		} else {
			cast18 := int64(fcast18)

			if !(cast18 >= 0) {
				errors.Add(
					strings.Join(
						[]string{
							ref, "height"},
						"/"),
					fmt.Sprintf(
						"expected >= 0, but got: %d",
						cast18))
			} else if !(cast18 <= 300) {
				errors.Add(
					strings.Join(
						[]string{
							ref, "height"},
							"/"),
					fmt.Sprintf(
						"expected <= 300, but got: %d",
						cast18))
			} else {
				target.Height = cast18
			}
		}
	}

	if errors.Full() {
		return
	}

	////
	// Parse Fee
	////

	value19, ok19 := cast[
		"fee"]

	if !ok19 {
		errors.Add(
			ref,
			"property is missing: fee")
	} else {
		cast20, ok20 := value19.(float64)
		if !ok20 {
			errors.Add(
				strings.Join(
					[]string{
						ref, "fee"},
					"/"),
				fmt.Sprintf(
					"expected a float64, but got: %T",
					value19))
		} else {
			if !(cast20 >= 0) {
				errors.Add(
					strings.Join(
						[]string{
							ref, "fee"},
						"/"),
					fmt.Sprintf(
						"expected >= 0.000000, but got: %f",
						cast20))
			} else {
				target.Fee = cast20
			}
		}
	}

	if errors.Full() {
		return
	}

	return
}

// AddressFromJSONable parses Address from a JSONable value.
//
// If there are any errors, the state of the target is undefined.
//
// AddressFromJSONable requires:
//  * target != nil
//  * errors != nil
//  * errors.Empty()
func AddressFromJSONable(
	value interface{},
	ref string,
	target *Address,
	errors *Errors) {

	if target == nil {
		panic("unexpected nil target")
	}

	if errors == nil {
		panic("unexpected nil errors")
	}

	if !errors.Empty() {
		panic("unexpected non-empty errors")
	}

	cast, ok := value.(map[string]interface{})
	if !ok {
		errors.Add(
			ref,
			fmt.Sprintf(
				"expected a map[string]interface{}, but got: %T",
				value))
		return
	}

	////
	// Parse Text
	////

	value0, ok0 := cast[
		"text"]

	if !ok0 {
		errors.Add(
			ref,
			"property is missing: text")
	} else {
		cast1, ok1 := value0.(string)
		if !ok1 {
			errors.Add(
				strings.Join(
					[]string{
						ref, "text"},
					"/"),
				fmt.Sprintf(
					"expected a string, but got: %T",
					value0))
		} else {
			target.Text = cast1
		}
	}

	if errors.Full() {
		return
	}

	////
	// Parse TimeZone
	////

	value2, ok2 := cast[
		"time_zone"]

	if !ok2 {
		errors.Add(
			ref,
			"property is missing: time_zone")
	} else {
		cast3, ok3 := value2.(string)
		if !ok3 {
			errors.Add(
				strings.Join(
					[]string{
						ref, "time_zone"},
					"/"),
				fmt.Sprintf(
					"expected a string, but got: %T",
					value2))
		} else {
			target3, err3 := time.LoadLocation(cast3)
			if err3 != nil {
				errors.Add(
					strings.Join(
						[]string{
							ref, "time_zone"},
						"/"),
					fmt.Sprintf(
						"failed to load location from %#v: %s",
						cast3,
						err3.Error()))
			} else {
				target.TimeZone = target3
			}
		}
	}

	if errors.Full() {
		return
	}

	return
}

// PipelineFromJSONable parses Pipeline from a JSONable value.
//
// If there are any errors, the state of target is undefined.
//
// PipelineFromJSONable requires:
//  * target != nil
//  * errors != nil
//  * errors.Empty()
func PipelineFromJSONable(
	value interface{},
	ref string,
	target *Pipeline,
	errors *Errors) {

	if target == nil {
		panic("unexpected nil target")
	}

	if errors == nil {
		panic("unexpected nil errors")
	}

	if !errors.Empty() {
		panic("unexpected non-empty errors")
	}

	cast, ok := value.(map[string]interface{})
	if !ok {
		errors.Add(
			ref,
			fmt.Sprintf(
				"expected a map[string]interface{}, but got: %T",
				value))
		return
	}

	////
	// Pre-allocate Persons
	////

	personsRef := ref+"/persons";
	var personsOk bool
	var personsValue interface{}
	var personsMap map[string]interface{}

	personsValue, personsOk = cast[
		"persons"]
	if personsOk {
		personsMap, ok = personsValue.(map[string]interface{})
		if !ok {
			errors.Add(
				personsRef,
				fmt.Sprintf(
					"expected a map[string]interface{}, but got: %T",
					personsValue));
		} else {
			target.Persons = make(
				map[string]*Person)

			for id := range personsMap {
				target.Persons[id] = &Person{}
			}
		}
	}

	// Pre-allocating class instances is critical.
	// If the pre-allocation failed, we can not continue to parse the instances.
	if !errors.Empty() {
		return
	}

	////
	// Parse Persons
	////

	if personsOk {
		for id, value := range personsMap {
			PersonFromJSONable(
				value,
				id,
				target.Persons,
				strings.Join([]string{
					personsRef, id}, "/"),
				target.Persons[id],
				errors)

			if errors.Full() {
				break
			}
		}
	}

	if errors.Full() {
		return
	}

	////
	// Parse Maintainer
	////

	value0, ok0 := cast[
		"maintainer"]

	if !ok0 {
		errors.Add(
			ref,
			"property is missing: maintainer")
	} else {
		cast1, ok1 := value0.(string)
		if !ok1 {
			errors.Add(
				strings.Join(
					[]string{
						ref, "maintainer"},
					"/"),
				fmt.Sprintf(
					"expected a string, but got: %T",
					value0))
		} else {
			target1, ok1 := target.Persons[cast1]
			if !ok1 {
				errors.Add(
					strings.Join(
						[]string{
							ref, "maintainer"},
						"/"),
					fmt.Sprintf(
						"reference to an instance of class Person not found: %s",
						value0))
			} else {
				target.Maintainer = target1
			}
		}
	}

	if errors.Full() {
		return
	}

	return
}

// File automatically generated by mapry. DO NOT EDIT OR APPEND!
