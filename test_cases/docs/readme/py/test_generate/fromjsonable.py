# File automatically generated by mapry. DO NOT EDIT OR APPEND!


"""parses JSONable objects."""


import collections
import datetime
import pathlib
import re
import typing

import pytz
import pytz.exceptions  # type: ignore

import book.address
import book.address.parse


_DURATION_RE = re.compile(
    r'^(?P<sign>\+|-)?P'
    r'((?P<years>(0|[1-9][0-9]*)(\.[0-9]+)?)Y)?'
    r'((?P<months>(0|[1-9][0-9]*)(\.[0-9]+)?)M)?'
    r'((?P<weeks>(0|[1-9][0-9]*)(\.[0-9]+)?)W)?'
    r'((?P<days>(0|[1-9][0-9]*)(\.[0-9]+)?)D)?'
    r'(T'
    r'((?P<hours>(0|[1-9][0-9]*)(\.[0-9]+)?)H)?'
    r'((?P<minutes>(0|[1-9][0-9]*)(\.[0-9]+)?)M)?'
    r'(((?P<seconds>0|[1-9][0-9]*)(\.(?P<fraction>[0-9]+))?)S)?'
    r')?$')


def _duration_from_string(text: str) -> datetime.timedelta:
    """
    parses the duration from the string in ISO 8601 format.

    Following C++ chrono library, the following units are counted as:

    * years as 365.2425 days (the average length of a Gregorian year),
    * months as 30.436875 days (exactly 1/12 of years) and
    * weeks as 7 days.

    :param text: string to be parsed
    :return: duration
    :raise:
        ValueError if the string could not be parsed,
        ValueError if the fraction precision is higher than microseconds
        OverflowError if the duration does not fit into datetime.timedelta


    >>> _duration_from_string('P10Y')
    datetime.timedelta(3652, 36720)

    >>> _duration_from_string('P1M')
    datetime.timedelta(30, 37746)

    >>> _duration_from_string('P1W')
    datetime.timedelta(7)

    >>> _duration_from_string('P1D')
    datetime.timedelta(1)

    >>> _duration_from_string('PT1H1M1S')
    datetime.timedelta(0, 3661)

    >>> _duration_from_string('PT1H1M1.1S')
    datetime.timedelta(0, 3661, 100000)

    >>> _duration_from_string('PT')
    datetime.timedelta(0)

    >>> _duration_from_string('P1.1Y1.1M1.1W1.1DT1.1H1.1M1.1S')
    datetime.timedelta(444, 8114, 900000)

    >>> _duration_from_string('PT0.000001S')
    datetime.timedelta(0, 0, 1)

    >>> _duration_from_string('PT1.000S')
    datetime.timedelta(0, 1)

    >>> _duration_from_string('-P1D')
    datetime.timedelta(-1)

    """
    match = _DURATION_RE.match(text)

    if not match:
        raise ValueError(
            'Failed to match the duration: {!r}'.format(
                text))

    sign_grp = match.group('sign')
    if not sign_grp or sign_grp == '+':
        sign = 1
    else:
        sign = -1

    years_grp = match.group('years')
    years = float(years_grp) if years_grp else 0.0

    months_grp = match.group('months')
    months = float(months_grp) if months_grp else 0.0

    weeks_grp = match.group('weeks')
    weeks = float(weeks_grp) if weeks_grp else 0.0

    days_grp = match.group('days')
    days = float(days_grp) if days_grp else 0.0

    hours_grp = match.group('hours')
    hours = float(hours_grp) if hours_grp else 0.0

    minutes_grp = match.group('minutes')
    minutes = float(minutes_grp) if minutes_grp else 0.0

    seconds_grp = match.group('seconds')
    seconds = int(seconds_grp) if seconds_grp else 0

    fraction_grp = match.group('fraction')
    if not fraction_grp:
        microseconds = 0

    elif len(fraction_grp) > 6:
        raise ValueError(
            ('Precision only up to microseconds supported, '
             'but got: {}').format(text))

    else:
        stripped = fraction_grp.lstrip('0')
        if stripped:
            count = int(stripped)
            order = 6 - len(fraction_grp)
            microseconds = count * (10 ** order)
        else:
            microseconds = 0
    try:
        return sign * datetime.timedelta(
            days=years * 365.2425 + months * 30.436875 + weeks * 7 + days,
            seconds=seconds,
            minutes=minutes,
            hours=hours,
            microseconds=microseconds)

    except OverflowError as err:
        raise OverflowError(
            'Creating a timedelta overflowed from: {!r}'.format(
                text)) from err


def _person_from(
        value: typing.Any,
        persons_registry: typing.Mapping[
            str,
            book.address.Person],
        ref: str,
        target: book.address.Person,
        errors: book.address.parse.Errors
) -> None:
    """
    parses Person from a JSONable value.

    If ``errors``, the attributes of ``target`` have undefined values.

    :param value: JSONable value
    :param persons_registry: registry of the Person instances
    :param ref:
        reference to the value (e.g., a reference path)
    :param target: parsed ``value`` as Person
    :param errors: errors encountered during parsing
    :return:

    """
    if not isinstance(value, dict):
        errors.add(
            ref,
            "Expected a dictionary, but got: {}".format(
                type(value)))
        return

    ##
    # Parse full_name
    ##

    value_0 = value.get(
        'full_name',
        None)

    if value_0 is None:
        errors.add(
            ref,
            'Property is missing: full_name')
    else:
        if not isinstance(value_0, str):
            errors.add(
                '/'.join((
                    ref, 'full_name')),
                "Expected a string, but got: {}".format(
                    type(value_0)))
        else:
            target.full_name = value_0
    if errors.full():
        return

    ##
    # Parse address
    ##

    value_2 = value.get(
        'address',
        None)

    if value_2 is None:
        errors.add(
            ref,
            'Property is missing: address')
    else:
        target_3 = (
            book.address.parse.placeholder_address()
        )
        _address_from(
            value_2,
            '/'.join((
                ref, 'address')),
            target_3,
            errors)
        target.address = target_3
    if errors.full():
        return

    ##
    # Parse picture
    ##

    value_4 = value.get(
        'picture',
        None)

    if value_4 is not None:
        if not isinstance(value_4, str):
            errors.add(
                '/'.join((
                    ref, 'picture')),
                "Expected a string, but got: {}".format(
                    type(value_4)))
        else:
            if not re.match(
                    r'^/images/.*$',
                    value_4):
                errors.add(
                    '/'.join((
                        ref, 'picture')),
                    'Expected to match ^/images/.*$, but got: {}'.format(
                        value_4))
            else:
                target.picture = pathlib.Path(
                    value_4)
    if errors.full():
        return

    ##
    # Parse birthday
    ##

    value_6 = value.get(
        'birthday',
        None)

    if value_6 is None:
        errors.add(
            ref,
            'Property is missing: birthday')
    else:
        if not isinstance(value_6, str):
            errors.add(
                '/'.join((
                    ref, 'birthday')),
                "Expected a string, but got: {}".format(
                    type(value_6)))
        else:
            try:
                target.birthday = datetime.datetime.strptime(
                    value_6,
                    '%Y-%m-%d'
                ).date()
            except ValueError:
                errors.add(
                    '/'.join((
                        ref, 'birthday')),
                    'Expected to strptime %Y-%m-%d, but got: {}'.format(
                        value_6))
    if errors.full():
        return

    ##
    # Parse last_modified
    ##

    value_8 = value.get(
        'last_modified',
        None)

    if value_8 is None:
        errors.add(
            ref,
            'Property is missing: last_modified')
    else:
        if not isinstance(value_8, str):
            errors.add(
                '/'.join((
                    ref, 'last_modified')),
                "Expected a string, but got: {}".format(
                    type(value_8)))
        else:
            try:
                target.last_modified = datetime.datetime.strptime(
                    value_8,
                    '%Y-%m-%dT%H:%M:%SZ')
            except ValueError:
                errors.add(
                    '/'.join((
                        ref, 'last_modified')),
                    'Expected to strptime %Y-%m-%dT%H:%M:%SZ, but got: {}'.format(
                        value_8))
    if errors.full():
        return

    ##
    # Parse contact_period
    ##

    value_10 = value.get(
        'contact_period',
        None)

    if value_10 is None:
        errors.add(
            ref,
            'Property is missing: contact_period')
    else:
        if not isinstance(value_10, str):
            errors.add(
                '/'.join((
                    ref, 'contact_period')),
                "Expected a string, but got: {}".format(
                    type(value_10)))
        else:
            try:
                target.contact_period = _duration_from_string(
                    value_10)
            except (ValueError, OverflowError) as err:
                errors.add(
                    '/'.join((
                        ref, 'contact_period')),
                    str(err))
    if errors.full():
        return

    ##
    # Parse friends
    ##

    value_12 = value.get(
        'friends',
        None)

    if value_12 is None:
        errors.add(
            ref,
            'Property is missing: friends')
    else:
        if not isinstance(value_12, dict):
            errors.add(
                '/'.join((
                    ref, 'friends')),
                "Expected a dict, but got: {}".format(
                    type(value_12)))
        else:
            if isinstance(value_12, collections.OrderedDict):
                target_13 = (
                    collections.OrderedDict()
                )  # type: typing.MutableMapping[str, book.address.Person]
            else:
                target_13 = (
                    dict()
                )

            for key_13, value_13 in value_12.items():
                if not isinstance(key_13, str):
                    errors.add(
                        '/'.join((
                            ref, 'friends')),
                        "Expected the key to be a str, but got: {}".format(
                            type(key_13)))

                    if errors.full():
                        break
                    else:
                        continue

                target_item_13 = (
                    None
                )  # type: typing.Optional[book.address.Person]
                if not isinstance(value_13, str):
                    errors.add(
                        '/'.join((
                            ref, 'friends', repr(key_13))),
                        "Expected a str, but got: {}".format(
                            type(value_13)))
                else:
                    target_14 = persons_registry.get(
                        value_13,
                        None)
                    if target_14 is None:
                        errors.add(
                            '/'.join((
                                ref, 'friends', repr(key_13))),
                            'Reference to an instance of class Person not found: {}'.format(
                                value_13))
                    else:
                        target_item_13 = target_14

                if target_item_13 is not None:
                    target_13[key_13] = target_item_13

                if errors.full():
                    break

            if target_13 is not None:
                target.friends = target_13
    if errors.full():
        return

    ##
    # Parse active
    ##

    value_15 = value.get(
        'active',
        None)

    if value_15 is None:
        errors.add(
            ref,
            'Property is missing: active')
    else:
        if not isinstance(value_15, bool):
            errors.add(
                '/'.join((
                    ref, 'active')),
                "Expected a bool, but got: {}".format(
                    type(value_15)))
        else:
            target.active = value_15
    if errors.full():
        return

    ##
    # Parse height
    ##

    value_17 = value.get(
        'height',
        None)

    if value_17 is None:
        errors.add(
            ref,
            'Property is missing: height')
    else:
        if not isinstance(value_17, int):
            errors.add(
                '/'.join((
                    ref, 'height')),
                "Expected an integer, but got: {}".format(
                    type(value_17)))
        else:
            if not (value_17 >= 0):
                errors.add(
                    '/'.join((
                        ref, 'height')),
                    'Expected >= 0, but got: {}'.format(
                        value_17))
            if not (value_17 <= 300):
                errors.add(
                    '/'.join((
                        ref, 'height')),
                    'Expected <= 300, but got: {}'.format(
                        value_17))
            else:
                target.height = value_17
    if errors.full():
        return

    ##
    # Parse fee
    ##

    value_19 = value.get(
        'fee',
        None)

    if value_19 is None:
        errors.add(
            ref,
            'Property is missing: fee')
    else:
        if not isinstance(value_19, (int, float)):
            errors.add(
                '/'.join((
                    ref, 'fee')),
                'Expected a number, but got: {}'.format(
                    type(value_19)))
        else:
            if not (value_19 >= 0):
                errors.add(
                    '/'.join((
                        ref, 'fee')),
                    'Expected >= 0, but got: {}'.format(
                        value_19))
            else:
                target.fee = float(value_19)
    if errors.full():
        return


def person_from(
        value: typing.Any,
        id: str,
        persons_registry: typing.Mapping[
            str,
            book.address.Person],
        ref: str,
        errors: book.address.parse.Errors
) -> typing.Optional[book.address.Person]:
    """
    parses Person from a JSONable value.

    :param value: JSONable value
    :param id: identifier of the instance
    :param persons_registry:
        registry of the Person instances
    :param ref:
        reference to the value (e.g., a reference path)
    :param errors: errors encountered during parsing
    :return: parsed instance, or None if ``errors``

    """
    target = book.address.parse.placeholder_person(id=id)

    _person_from(
        value=value,
        persons_registry=persons_registry,
        ref=ref,
        target=target,
        errors=errors)

    if not errors.empty():
       return None

    return target


def _address_from(
        value: typing.Any,
        ref: str,
        target: book.address.Address,
        errors: book.address.parse.Errors
) -> None:
    """
    parses Address from a JSONable value.

    If ``errors``, the attributes of ``target`` have undefined values.

    :param value: JSONable value
    :param ref:
        reference to the value (e.g., a reference path)
    :param target: parsed ``value`` as Address
    :param errors: errors encountered during parsing
    :return:

    """
    if not isinstance(value, dict):
        errors.add(
            ref,
            "Expected a dictionary, but got: {}".format(
                type(value)))
        return

    ##
    # Parse text
    ##

    value_0 = value.get(
        'text',
        None)

    if value_0 is None:
        errors.add(
            ref,
            'Property is missing: text')
    else:
        if not isinstance(value_0, str):
            errors.add(
                '/'.join((
                    ref, 'text')),
                "Expected a string, but got: {}".format(
                    type(value_0)))
        else:
            target.text = value_0
    if errors.full():
        return

    ##
    # Parse time_zone
    ##

    value_2 = value.get(
        'time_zone',
        None)

    if value_2 is None:
        errors.add(
            ref,
            'Property is missing: time_zone')
    else:
        if not isinstance(value_2, str):
            errors.add(
                '/'.join((
                    ref, 'time_zone')),
                "Expected a string, but got: {}".format(
                    type(value_2)))
        else:
            try:
                target.time_zone = pytz.timezone(
                    value_2)
            except pytz.exceptions.UnknownTimeZoneError:
                errors.add(
                    '/'.join((
                        ref, 'time_zone')),
                    "Expected a valid IANA time zone, but got: {}".format(
                        value_2))
    if errors.full():
        return


def address_from(
        value: typing.Any,
        ref: str,
        errors: book.address.parse.Errors
) -> typing.Optional[book.address.Address]:
    """
    parses Address from a JSONable value.

    :param value: JSONable value
    :param id: identifier of the instance
    :param ref:
        reference to the value (e.g., a reference path)
    :param errors: errors encountered during parsing
    :return: parsed instance, or None if ``errors``

    """
    target = book.address.parse.placeholder_address()

    _address_from(
        value=value,
        ref=ref,
        target=target,
        errors=errors)

    if not errors.empty():
       return None

    return target


def pipeline_from(
        value: typing.Any,
        ref: str,
        errors: book.address.parse.Errors
) -> typing.Optional[book.address.Pipeline]:
    """
    parses Pipeline from a JSONable value.

    :param value: JSONable value
    :param ref: reference to the value (e.g., a reference path)
    :param errors: errors encountered during parsing
    :return: parsed Pipeline, or None if ``errors``
    """
    if errors.full():
        return None

    if not isinstance(value, dict):
        errors.add(
            ref,
            "Expected a dictionary, but got: {}".format(type(value)))
        return None

    graph = book.address.parse.placeholder_pipeline()

    ##
    # Pre-allocate persons
    ##

    registry_value = value.get('persons', None)

    if registry_value is not None:
        if not isinstance(registry_value, dict):
            errors.add(
                '/'.join((
                    ref, 'persons')),
                "Expected a dictionary, but got: {}".format(
                    type(registry_value)))
        else:
            if isinstance(registry_value, collections.OrderedDict):
                graph.persons = collections.OrderedDict()
            else:
                graph.persons = dict()

            persons_registry = graph.persons
            for id in registry_value:
                persons_registry[id] = book.address.parse.placeholder_person(id=id)

    if errors.full():
        return None

    # Errors from pre-allocation are considered critical.
    if not errors.empty():
        return None

    ##
    # Parse persons
    ##

    if 'persons' in value:
        registry_value = value['persons']
        for id, instance_value in registry_value.items():
            target_person = graph.persons[id]
            target_person.id = id

            _person_from(
                instance_value,
                graph.persons,
                '/'.join((
                    ref, 'persons', repr(id))),
                target_person,
                errors)

            if errors.full():
                return None

    ##
    # Parse maintainer
    ##

    value_0 = value.get(
        'maintainer',
        None)

    if value_0 is None:
        errors.add(
            ref,
            'Property is missing: maintainer')
    else:
        if not isinstance(value_0, str):
            errors.add(
                '/'.join((
                    ref, 'maintainer')),
                "Expected a str, but got: {}".format(
                    type(value_0)))
        else:
            target_1 = graph.persons.get(
                value_0,
                None)
            if target_1 is None:
                errors.add(
                    '/'.join((
                        ref, 'maintainer')),
                    'Reference to an instance of class Person not found: {}'.format(
                        value_0))
            else:
                graph.maintainer = target_1

    if errors.full():
        return None

    if not errors.empty():
        return None

    return graph
