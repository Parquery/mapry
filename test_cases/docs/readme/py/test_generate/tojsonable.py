# File automatically generated by mapry. DO NOT EDIT OR APPEND!


"""serializes to JSONable objects."""


import collections
import datetime
import typing

import book.address


_ZERO_TIMEDELTA = datetime.timedelta(0)


def _duration_to_string(
        duration: datetime.timedelta) -> str:
    """
    serializes the duration to a string in ISO 8601 format.

    Since ``datetime.timedelta`` stores intervals only up to days and
    excludes longer intervals such as weeks, months and years,
    the serialized representation defines the duration only
    in terms of days and shorter intervals.

    :param duration: duration to be serialized
    :return: text representation

    >>> _duration_to_string(
    ...     datetime.timedelta(days=1, hours=2, minutes=3,
    ...     seconds=4, microseconds=5))
    'P1DT2H3M4.000005S'

    >>> _duration_to_string(
    ...     datetime.timedelta(hours=1, minutes=2, seconds=3))
    'PT1H2M3S'

    >>> _duration_to_string(
    ...     datetime.timedelta(seconds=1))
    'PT1S'

    >>> _duration_to_string(
    ...     datetime.timedelta(days=365.1))
    'P365DT2H24M'

    >>> _duration_to_string(
    ...     -datetime.timedelta(days=1))
    '-P1D'

    >>> _duration_to_string(
    ...     -datetime.timedelta(
    ...         days=1, hours=1, minutes=1,seconds=1,microseconds=1))
    '-P1DT1H1M1.000001S'

    """
    parts = []  # type: typing.List[str]

    absduration = duration
    if duration < _ZERO_TIMEDELTA:
        parts.append('-')
        absduration = -duration

    parts.append('P')
    if absduration.days > 0:
        parts.append('{}D'.format(absduration.days))

    if absduration.seconds > 0 or absduration.microseconds > 0:
        parts.append('T')

        rest = absduration.seconds
        hours = rest // 3600
        rest = rest % 3600

        minutes = rest // 60
        seconds = rest % 60

        if hours > 0:
            parts.append('{}H'.format(hours))

        if minutes > 0:
            parts.append('{}M'.format(minutes))

        if absduration.microseconds > 0:
            microseconds_str = '{:06}'.format(
                absduration.microseconds).rstrip('0')

            parts.append('{}.{}S'.format(seconds, microseconds_str))
        elif seconds > 0:
            parts.append('{}S'.format(seconds))
        else:
            # No microseconds nor seconds
            pass

    return ''.join(parts)


def serialize_person(
        instance: book.address.Person,
        ordered: bool = False
) -> typing.MutableMapping[str, typing.Any]:
    """
    serializes an instance of Person to a JSONable representation.

    :param instance: the instance of Person to be serialized
    :param ordered:
        If set, represents the instance as a ``collections.OrderedDict``.
        Otherwise, it is represented as a ``dict``.
    :return: a JSONable
    """
    if ordered:
        target = (
            collections.OrderedDict()
        )  # type: typing.MutableMapping[str, typing.Any]
    else:
        target = dict()

    ##
    # Serialize full_name
    ##

    target['full_name'] = instance.full_name

    ##
    # Serialize address
    ##

    target['address'] = serialize_address(instance.address)

    ##
    # Serialize picture
    ##

    if instance.picture is not None:
        target['picture'] = str(instance.picture)

    ##
    # Serialize birthday
    ##

    target['birthday'] = instance.birthday.strftime('%Y-%m-%d')

    ##
    # Serialize last_modified
    ##

    target['last_modified'] = instance.last_modified.strftime('%Y-%m-%dT%H:%M:%SZ')

    ##
    # Serialize contact_period
    ##

    target['contact_period'] = _duration_to_string(instance.contact_period)

    ##
    # Serialize friends
    ##

    if isinstance(instance.friends, collections.OrderedDict):
        target_0 = (
            collections.OrderedDict()
        )  # type: typing.MutableMapping[str, str]
    else:
        target_0 = dict()

    for key_0, value_0 in instance.friends.items():
        target_0[key_0] = value_0.id
    target['friends'] = target_0

    ##
    # Serialize active
    ##

    target['active'] = instance.active

    ##
    # Serialize height
    ##

    target['height'] = instance.height

    ##
    # Serialize fee
    ##

    target['fee'] = instance.fee

    return target


def serialize_address(
        instance: book.address.Address,
        ordered: bool = False
) -> typing.MutableMapping[str, typing.Any]:
    """
    serializes an instance of Address to a JSONable representation.

    :param instance: the instance of Address to be serialized
    :param ordered:
        If set, represents the instance as a ``collections.OrderedDict``.
        Otherwise, it is represented as a ``dict``.
    :return: a JSONable
    """
    if ordered:
        target = (
            collections.OrderedDict()
        )  # type: typing.MutableMapping[str, typing.Any]
    else:
        target = dict()

    ##
    # Serialize text
    ##

    target['text'] = instance.text

    ##
    # Serialize time_zone
    ##

    target['time_zone'] = str(instance.time_zone)

    return target


def serialize_pipeline(
        instance: book.address.Pipeline,
        ordered: bool = False
) -> typing.MutableMapping[str, typing.Any]:
    """
    serializes an instance of Pipeline to a JSONable.

    :param instance: the instance of Pipeline to be serialized
    :param ordered:
        If set, represents the instance properties and class registries
        as a ``collections.OrderedDict``.
        Otherwise, they are represented as a ``dict``.
    :return: JSONable representation
    """
    if ordered:
        target = (
            collections.OrderedDict()
        )  # type: typing.MutableMapping[str, typing.Any]
    else:
        target = dict()

    ##
    # Serialize maintainer
    ##

    target['maintainer'] = instance.maintainer.id

    ##
    # Serialize instance registry of Person
    ##

    if len(instance.persons) > 0:
        if ordered:
            target_persons = (
                collections.OrderedDict()
            )  # type: typing.MutableMapping[str, typing.Any]
        else:
            target_persons = dict()

        for id, person_instance in instance.persons.items():
            if id != person_instance.id:
                raise ValueError(
                    'Expected ID {!r} of the instance of Person, but got: {!r}'.format(
                        id, person_instance.id))

            target_persons[id] = serialize_person(
                instance=person_instance,
                ordered=ordered)
        target['persons'] = target_persons

    return target


# File automatically generated by mapry. DO NOT EDIT OR APPEND!
