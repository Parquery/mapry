// File automatically generated by mapry. DO NOT EDIT OR APPEND!

#include "jsoncpp.h"
#include "parse.h"
#include "types.h"

#include <cstring>
#include <memory>
#include <sstream>
#include <stdexcept>
#include <string>
#include <utility>

namespace book {
namespace address {

namespace jsoncpp {

/**
 * generates an error message.
 *
 * @param cc char array as the description part of the message
 * @param cc_size size of the char array
 * @param s string as the detail part of the message
 * @return concatenated string
 */
std::string message(const char* cc, size_t cc_size, std::string s) {
  std::string result;
  result.reserve(cc_size + s.size());
  result.append(cc, cc_size);
  result.append(s);
  return result;
}

/**
 * converts a JSON value type to a human-readable string representation.
 *
 * @param value_type to be converted
 * @return string representation of the JSON value type
 */
std::string value_type_to_string(Json::ValueType value_type) {
  switch (value_type) {
    case Json::ValueType::nullValue: return "null";
    case Json::ValueType::intValue: return "int";
    case Json::ValueType::uintValue: return "uint";
    case Json::ValueType::realValue: return "real";
    case Json::ValueType::stringValue: return "string";
    case Json::ValueType::booleanValue: return "bool";
    case Json::ValueType::arrayValue: return "array";
    case Json::ValueType::objectValue: return "object";
    default:
      std::stringstream ss;
      ss << "Unhandled value type in value_to_string: "
        << value_type;
      throw std::domain_error(ss.str());
  }
}

void pipeline_from(
    const Json::Value& value,
    std::string ref,
    Pipeline* target,
    parse::Errors* errors) {
  if (errors == nullptr) {
    throw std::invalid_argument("Unexpected null errors");
  }

  if (not errors->empty()) {
    throw std::invalid_argument("Unexpected non-empty errors");
  }

  if (not value.isObject()) {
    constexpr auto expected_but_got(
      "Expected an object, but got: ");

    errors->add(
      ref,
      message(
        expected_but_got,
        strlen(expected_but_got),
        value_type_to_string(
          value.type())));
    return;
  }

  ////
  // Pre-allocate persons
  ////

  std::string persons_ref;
  persons_ref.reserve(ref.size() + 8);
  persons_ref += ref;
  persons_ref += "/persons";

  if (value.isMember("persons")) {
    const Json::Value& obj = value["persons"];
    if (not obj.isObject()) {
      constexpr auto expected_but_got(
        "Expected an object, but got: ");

      errors->add(
        persons_ref,
        message(
          expected_but_got,
          strlen(expected_but_got),
          value_type_to_string(
            obj.type())));
    } else {
      for (Json::ValueConstIterator it = obj.begin();
          it != obj.end(); ++it) {
                auto instance = std::make_unique<Person>();
        instance->id = it.name();
        target->persons[it.name()] = std::move(instance);

      }
    }
  }

  // Pre-allocating class instances is critical.
  // If the pre-allocation failed, we can not continue to parse the instances.
  if (not errors->empty()) {
    return;
  }

  // Keep the prefix fixed in this buffer so that
  // it is copied as little as possible
  std::string instance_ref;

  ////
  // Parse persons
  ////

  // clear() does not shrink the reserved memory,
  // see https://en.cppreference.com/w/cpp/string/basic_string/clear
  instance_ref.clear();
  instance_ref += persons_ref;
  instance_ref += '/';

  if (value.isMember("persons")) {
    const Json::Value& obj = value["persons"];

    for (Json::ValueConstIterator it = obj.begin(); it != obj.end(); ++it) {
      instance_ref.reserve(
        persons_ref.size() + 1 + it.name().size());
      instance_ref.resize(
        persons_ref.size() + 1);
      instance_ref.append(
        it.name());

      Person* instance(
        target->persons.at(it.name()).get());
      person_from(
        *it,
        instance_ref,
        instance,
        errors);

      if (errors->full()) {
        break;
      }
    }
  }
  if (errors->full()) {
    return;
  }

  ////
  // Parse maintainer
  ////

  if (not value.isMember("maintainer")) {
    errors->add(
      ref,
      "Property is missing: maintainer");
  } else {
    const Json::Value& value_0 = value["maintainer"];
    if (not value_0.isString()) {
      constexpr auto expected_but_got(
        "Expected a string, but got: ");

      errors->add(
        std::string(ref)
          .append("/maintainer"),
        message(
          expected_but_got,
          strlen(expected_but_got),
          value_type_to_string(
            value_0.type())));
    } else {
      const std::string& cast_0 = value_0.asString();
      if (target->persons.count(cast_0) == 0) {
        constexpr auto reference_not_found(
          "Reference to an instance of class "
          "Person"
          " not found: ");

        errors->add(
          std::string(ref)
            .append("/maintainer"),
          message(
            reference_not_found,
            strlen(reference_not_found),
            cast_0));
      } else {
        target->maintainer = target->persons.at(cast_0).get();
      }
    }
  }
  if (errors->full()) {
    return;
  }
}

/**
 * serializes the date/time/datetime to a string.
 *
 * @param[in] t time structure
 * @param[in] fmt format
 * @return time structure serialized to a string according to the format
 */
std::string tm_to_string(const struct tm& t, const char* fmt) {{
  if(fmt == nullptr or fmt[0] == '\0') {
    return "";
  }

  const size_t fmt_size = strlen(fmt);

  std::string buf;
  buf.resize(fmt_size * 4);
  int len = strftime(&buf[0], buf.size(), fmt, &t);

  while(len == 0) {{
    buf.resize(buf.size() * 2);
    int len = strftime(&buf[0], buf.size(), fmt, &t);
  }}
  buf.resize(len);
  return buf;
}}

void person_from(
    const Json::Value& value,
    std::string ref,
    Person* target,
    parse::Errors* errors) {
  if (not value.isObject()) {
    constexpr auto expected_but_got(
      "Expected an object, but got: ");

    errors->add(
      ref,
      message(
        expected_but_got,
        strlen(expected_but_got),
        value_type_to_string(
          value.type())));
    return;
  }

  ////
  // Parse full_name
  ////

  if (not value.isMember("full_name")) {
    errors->add(
      ref,
      "Property is missing: full_name");
  } else {
    const Json::Value& value_0 = value["full_name"];
    if (not value_0.isString()) {
      constexpr auto expected_but_got(
        "Expected a string, but got: ");

      errors->add(
        std::string(ref)
          .append("/full_name"),
        message(
          expected_but_got,
          strlen(expected_but_got),
          value_type_to_string(
            value_0.type())));
    } else {
      target->full_name = value_0.asString();
    }
  }
  if (errors->full()) {
    return;
  }

  ////
  // Parse birthday
  ////

  if (not value.isMember("birthday")) {
    errors->add(
      ref,
      "Property is missing: birthday");
  } else {
    const Json::Value& value_1 = value["birthday"];
    if (not value_1.isString()) {
      constexpr auto expected_but_got(
        "Expected a string, but got: ");

      errors->add(
        std::string(ref)
          .append("/birthday"),
        message(
          expected_but_got,
          strlen(expected_but_got),
          value_type_to_string(
            value_1.type())));
    } else {
      const std::string cast_1 = value_1.asString();
      struct tm tm_1 = tm{0};
      char* ret_1 = strptime(
        cast_1.c_str(),
        "%Y-%m-%d",
        &tm_1);

      if (ret_1 == nullptr or *ret_1 != '\0') {
        constexpr auto expected_but_got(
          "Expected to strptime "
          "%Y-%m-%d"
          ", but got: ");

        errors->add(
          std::string(ref)
            .append("/birthday"),
          message(
            expected_but_got,
            strlen(expected_but_got),
            cast_1));
      } else {
        target->birthday = tm_1;
      }
    }
  }
  if (errors->full()) {
    return;
  }

  ////
  // Parse address
  ////

  if (not value.isMember("address")) {
    errors->add(
      ref,
      "Property is missing: address");
  } else {
    const Json::Value& value_2 = value["address"];
    address_from(
      value_2,
      std::string(ref)
        .append("/address"),
      &target->address,
      errors);
  }
  if (errors->full()) {
    return;
  }
}

void address_from(
    const Json::Value& value,
    std::string ref,
    Address* target,
    parse::Errors* errors) {
  if (not value.isObject()) {
    constexpr auto expected_but_got(
      "Expected an object, but got: ");

    errors->add(
      ref,
      message(
        expected_but_got,
        strlen(expected_but_got),
        value_type_to_string(
          value.type())));
    return;
  }

  ////
  // Parse text
  ////

  if (not value.isMember("text")) {
    errors->add(
      ref,
      "Property is missing: text");
  } else {
    const Json::Value& value_0 = value["text"];
    if (not value_0.isString()) {
      constexpr auto expected_but_got(
        "Expected a string, but got: ");

      errors->add(
        std::string(ref)
          .append("/text"),
        message(
          expected_but_got,
          strlen(expected_but_got),
          value_type_to_string(
            value_0.type())));
    } else {
      target->text = value_0.asString();
    }
  }
  if (errors->full()) {
    return;
  }
}

Json::Value serialize_person(
    const Person& person) {
  Json::Value person_as_value;

  person_as_value["full_name"] = person.full_name;

  person_as_value["birthday"] = tm_to_string(
    person.birthday,
    "%Y-%m-%d");

  person_as_value["address"] = serialize_address(person.address);

  return person_as_value;
}

Json::Value serialize_address(
    const Address& address) {
  Json::Value address_as_value;

  address_as_value["text"] = address.text;

  return address_as_value;
}

Json::Value serialize_pipeline(
    const Pipeline& pipeline) {
  Json::Value pipeline_as_value;

  pipeline_as_value["maintainer"] = pipeline.maintainer->id;

  if (not pipeline.persons.empty()) {
    Json::Value persons_as_value;
    for (const auto& kv : pipeline.persons) {
      const std::string& id = kv.first;
      const Person* instance = kv.second.get();

      if (id != instance->id) {
        constexpr auto expected(
          "Expected the class instance of "
          "Person"
          "to have the ID ");
        constexpr auto but_got(", but got: ");

        std::string msg;
        msg.reserve(
          strlen(expected) + id.size() +
          strlen(but_got) + instance->id.size());
        msg += expected;
        msg += id;
        msg += but_got;
        msg += instance->id;

        throw std::invalid_argument(msg);
      }

      persons_as_value[instance->id] = serialize_person(*instance);
    }
    pipeline_as_value["persons"] = persons_as_value;
  }

  return pipeline_as_value;
}

}  // namespace jsoncpp

}  // namespace address
}  // namespace book

// File automatically generated by mapry. DO NOT EDIT OR APPEND!
