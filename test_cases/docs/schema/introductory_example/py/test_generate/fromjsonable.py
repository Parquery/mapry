# File automatically generated by mapry. DO NOT EDIT OR APPEND!


"""parses JSONable objects."""


import collections
import datetime
import typing

import book.address
import book.address.parse


def _person_from(
        value: typing.Any,
        ref: str,
        target: book.address.Person,
        errors: book.address.parse.Errors
) -> None:
    """
    parses Person from a JSONable value.

    If ``errors``, the attributes of ``target`` have undefined values.

    :param value: JSONable value
    :param ref:
        reference to the value (e.g., a reference path)
    :param target: parsed ``value`` as Person
    :param errors: errors encountered during parsing
    :return:

    """
    if not isinstance(value, dict):
        errors.add(
            ref,
            "Expected a dictionary, but got: {}".format(
                type(value)))
        return

    ##
    # Parse full_name
    ##

    value_0 = value.get(
        'full_name',
        None)

    if value_0 is None:
        errors.add(
            ref,
            'Property is missing: full_name')
    else:
        if not isinstance(value_0, str):
            errors.add(
                '/'.join((
                    ref, 'full_name')),
                "Expected a string, but got: {}".format(
                    type(value_0)))
        else:
            target.full_name = value_0
    if errors.full():
        return

    ##
    # Parse birthday
    ##

    value_2 = value.get(
        'birthday',
        None)

    if value_2 is None:
        errors.add(
            ref,
            'Property is missing: birthday')
    else:
        if not isinstance(value_2, str):
            errors.add(
                '/'.join((
                    ref, 'birthday')),
                "Expected a string, but got: {}".format(
                    type(value_2)))
        else:
            try:
                target.birthday = datetime.datetime.strptime(
                    value_2,
                    '%Y-%m-%d'
                ).date()
            except ValueError:
                errors.add(
                    '/'.join((
                        ref, 'birthday')),
                    'Expected to strptime %Y-%m-%d, but got: {}'.format(
                        value_2))
    if errors.full():
        return

    ##
    # Parse address
    ##

    value_4 = value.get(
        'address',
        None)

    if value_4 is None:
        errors.add(
            ref,
            'Property is missing: address')
    else:
        target_5 = (
            book.address.parse.placeholder_address()
        )
        _address_from(
            value_4,
            '/'.join((
                ref, 'address')),
            target_5,
            errors)
        target.address = target_5
    if errors.full():
        return


def person_from(
        value: typing.Any,
        id: str,
        ref: str,
        errors: book.address.parse.Errors
) -> typing.Optional[book.address.Person]:
    """
    parses Person from a JSONable value.

    :param value: JSONable value
    :param id: identifier of the instance
    :param ref:
        reference to the value (e.g., a reference path)
    :param errors: errors encountered during parsing
    :return: parsed instance, or None if ``errors``

    """
    target = book.address.parse.placeholder_person(id=id)

    _person_from(
        value=value,
        ref=ref,
        target=target,
        errors=errors)

    if not errors.empty():
       return None

    return target


def _address_from(
        value: typing.Any,
        ref: str,
        target: book.address.Address,
        errors: book.address.parse.Errors
) -> None:
    """
    parses Address from a JSONable value.

    If ``errors``, the attributes of ``target`` have undefined values.

    :param value: JSONable value
    :param ref:
        reference to the value (e.g., a reference path)
    :param target: parsed ``value`` as Address
    :param errors: errors encountered during parsing
    :return:

    """
    if not isinstance(value, dict):
        errors.add(
            ref,
            "Expected a dictionary, but got: {}".format(
                type(value)))
        return

    ##
    # Parse text
    ##

    value_0 = value.get(
        'text',
        None)

    if value_0 is None:
        errors.add(
            ref,
            'Property is missing: text')
    else:
        if not isinstance(value_0, str):
            errors.add(
                '/'.join((
                    ref, 'text')),
                "Expected a string, but got: {}".format(
                    type(value_0)))
        else:
            target.text = value_0
    if errors.full():
        return


def address_from(
        value: typing.Any,
        ref: str,
        errors: book.address.parse.Errors
) -> typing.Optional[book.address.Address]:
    """
    parses Address from a JSONable value.

    :param value: JSONable value
    :param id: identifier of the instance
    :param ref:
        reference to the value (e.g., a reference path)
    :param errors: errors encountered during parsing
    :return: parsed instance, or None if ``errors``

    """
    target = book.address.parse.placeholder_address()

    _address_from(
        value=value,
        ref=ref,
        target=target,
        errors=errors)

    if not errors.empty():
       return None

    return target


def pipeline_from(
        value: typing.Any,
        ref: str,
        errors: book.address.parse.Errors
) -> typing.Optional[book.address.Pipeline]:
    """
    parses Pipeline from a JSONable value.

    :param value: JSONable value
    :param ref: reference to the value (e.g., a reference path)
    :param errors: errors encountered during parsing
    :return: parsed Pipeline, or None if ``errors``
    """
    if errors.full():
        return None

    if not isinstance(value, dict):
        errors.add(
            ref,
            "Expected a dictionary, but got: {}".format(type(value)))
        return None

    graph = book.address.parse.placeholder_pipeline()

    ##
    # Pre-allocate persons
    ##

    registry_value = value.get('persons', None)

    if registry_value is not None:
        if not isinstance(registry_value, dict):
            errors.add(
                '/'.join((
                    ref, 'persons')),
                "Expected a dictionary, but got: {}".format(
                    type(registry_value)))
        else:
            if isinstance(registry_value, collections.OrderedDict):
                graph.persons = collections.OrderedDict()
            else:
                graph.persons = dict()

            persons_registry = graph.persons
            for id in registry_value:
                persons_registry[id] = book.address.parse.placeholder_person(id=id)

    if errors.full():
        return None

    # Errors from pre-allocation are considered critical.
    if not errors.empty():
        return None

    ##
    # Parse persons
    ##

    if 'persons' in value:
        registry_value = value['persons']
        for id, instance_value in registry_value.items():
            target_person = graph.persons[id]
            target_person.id = id

            _person_from(
                instance_value,
                '/'.join((
                    ref, 'persons', repr(id))),
                target_person,
                errors)

            if errors.full():
                return None

    ##
    # Parse maintainer
    ##

    value_0 = value.get(
        'maintainer',
        None)

    if value_0 is None:
        errors.add(
            ref,
            'Property is missing: maintainer')
    else:
        if not isinstance(value_0, str):
            errors.add(
                '/'.join((
                    ref, 'maintainer')),
                "Expected a str, but got: {}".format(
                    type(value_0)))
        else:
            target_1 = graph.persons.get(
                value_0,
                None)
            if target_1 is None:
                errors.add(
                    '/'.join((
                        ref, 'maintainer')),
                    'Reference to an instance of class Person not found: {}'.format(
                        value_0))
            else:
                graph.maintainer = target_1

    if errors.full():
        return None

    if not errors.empty():
        return None

    return graph
