package somegraph

// File automatically generated by mapry. DO NOT EDIT OR APPEND!

import (
	"fmt"
	"math"
	"regexp"
	"strconv"
	"strings"
	"time"
)

var durationRe = regexp.MustCompile(
	`^(-|\+)?P`+
	`(((0|[1-9][0-9]*)(\.[0-9]+)?)Y)?`+
	`(((0|[1-9][0-9]*)(\.[0-9]+)?)M)?`+
	`(((0|[1-9][0-9]*)(\.[0-9]+)?)W)?`+
	`(((0|[1-9][0-9]*)(\.[0-9]+)?)D)?`+
	`(T`+
	`(((0|[1-9][0-9]*)(\.[0-9]+)?)H)?`+
	`(((0|[1-9][0-9]*)(\.[0-9]+)?)M)?`+
	`(((0|[1-9][0-9]*)(\.([0-9]+))?)S)?`+
	`)?$`)

// addDuration adds right nanoseconds to the left duration.
//
// addDurationInt64 requires:
//  * left >= 0
//  * right >= 0
func addDuration(
	left time.Duration,
	right float64) (result time.Duration, overflow bool) {

	if !(left >= 0) {
		panic("Expected left >= 0")
	}

	if !(right >= 0) {
		panic("Expected right >= 0")
	}

	// 9223372036854775808.0 == 2^63 is the first float > MaxInt64.
	if right >= 9223372036854775808.0 {
		overflow = true
		return
	}

	rightAsNs := time.Duration(right)
	if rightAsNs > math.MaxInt64 - left {
		overflow = true
		return
	}

	result = left + rightAsNs
	return
}

// durationFromString parses the duration as ISO 8601 format.
//
// Following C++ chrono library, the following units are counted as:
//  * years as 365.2425 days (the average length of a Gregorian year),
//  * months as 30.436875 days (exactly 1/12 of years) and
//  * weeks as 7 days.
//
// Since time.Duration is measured in nanoseconds, beware of overflow
// issues due to finite representation of integers.
func durationFromString(s string) (d time.Duration, err error) {
	m := durationRe.FindStringSubmatch(s)

	if len(m) == 0 {
		err = fmt.Errorf("failed to match the duration pattern")
		return
	}

	////
	// Interprete
	////

	var years, months, weeks, days, hours, minutes float64
	var seconds, nanoseconds int64

	sign := int64(1)
	if len(m[1]) > 0 && m[1][0] == '-' {
		sign = -1
	}

	if len(m[3]) > 0 {
		years, err = strconv.ParseFloat(m[3], 64)
		if err != nil {
			err = fmt.Errorf("failed to parse the years: %s", err.Error())
			return
		}
	}

	if len(m[7]) > 0 {
		months, err = strconv.ParseFloat(m[7], 64)
		if err != nil {
			err = fmt.Errorf("failed to parse the months: %s", err.Error())
			return
		}
	}

	if len(m[11]) > 0 {
		weeks, err = strconv.ParseFloat(m[11], 64)
		if err != nil {
			err = fmt.Errorf("failed to parse the weeks: %s", err.Error())
			return
		}
	}

	if len(m[15]) > 0 {
		days, err = strconv.ParseFloat(m[15], 64)
		if err != nil {
			err = fmt.Errorf("failed to parse the days: %s", err.Error())
			return
		}
	}

	if len(m[20]) > 0 {
		hours, err = strconv.ParseFloat(m[20], 64)
		if err != nil {
			err = fmt.Errorf("failed to parse the hours: %s", err.Error())
			return
		}
	}

	if len(m[24]) > 0 {
		minutes, err = strconv.ParseFloat(m[24], 64)
		if err != nil {
			err = fmt.Errorf("failed to parse the minutes: %s", err.Error())
			return
		}
	}

	if len(m[29]) > 0 {
		seconds, err = strconv.ParseInt(m[29], 10, 64)
		if err != nil {
			err = fmt.Errorf("failed to parse the seconds: %s", err.Error())
			return
		}
	}

	switch {
	case len(m[31]) == 0:
		// pass
	case len(m[31]) <= 9:
		trimmed := strings.TrimLeft(m[31], "0")
		if len(trimmed) > 0 {
			nanoseconds, err = strconv.ParseInt(trimmed, 10, 64)
			if err != nil {
				err = fmt.Errorf(
					"failed to parse nanoseconds from: %s",
					err.Error())
			}

			order := 9 - len(m[31])
			for i := 0; i < order; i++ {
				nanoseconds *= 10
			}
		}
	default:
		err = fmt.Errorf(
			"precision only up to nanoseconds supported")
		return
	}

	////
	// Sum
	////

	d = time.Duration(nanoseconds)

	if seconds > (math.MaxInt64 / (1000 * 1000 * 1000)) {
		err = fmt.Errorf("seconds overflow in nanoseconds")
		return
	}

	secondsAsNs := time.Duration(seconds * 1000 * 1000 * 1000)
	if secondsAsNs > math.MaxInt64 - d {
		err = fmt.Errorf(
			"overflow in nanoseconds")
		return
	}
	d += secondsAsNs

	var overflow bool
	d, overflow = addDuration(d, minutes * 6e10)
	if overflow {
		err = fmt.Errorf("overflow in nanoseconds")
		return
	}

	d, overflow = addDuration(d, hours * 3.6e12)
	if overflow {
		err = fmt.Errorf("overflow in nanoseconds")
		return
	}

	d, overflow = addDuration(d, days * 24.0 * 3.6e12)
	if overflow {
		err = fmt.Errorf("overflow in nanoseconds")
		return
	}

	d, overflow = addDuration(d, weeks * 7.0 * 24.0 * 3.6e12)
	if overflow {
		err = fmt.Errorf("overflow in nanoseconds")
		return
	}

	d, overflow = addDuration(d, months * 30.436875 * 24.0 * 3.6e12)
	if overflow {
		err = fmt.Errorf("overflow in nanoseconds")
		return
	}

	d, overflow = addDuration(d, years * 365.2425 * 24.0 * 3.6e12)
	if overflow {
		err = fmt.Errorf("overflow in nanoseconds")
		return
	}

	// d is always positive, so the multiplication by -1 can not
	// overflow since |math.MaxInt64| < |math.MinInt64|
	d *= time.Duration(sign);

	return
}

// SomeGraphFromJSONable parses SomeGraph from a JSONable value.
//
// If there are any errors, the state of target is undefined.
//
// SomeGraphFromJSONable requires:
//  * target != nil
//  * errors != nil
//  * errors.Empty()
func SomeGraphFromJSONable(
	value interface{},
	ref string,
	target *SomeGraph,
	errors *Errors) {

	if target == nil {
		panic("unexpected nil target")
	}

	if errors == nil {
		panic("unexpected nil errors")
	}

	if !errors.Empty() {
		panic("unexpected non-empty errors")
	}

	cast, ok := value.(map[string]interface{})
	if !ok {
		errors.Add(
			ref,
			fmt.Sprintf(
				"expected a map[string]interface{}, but got: %T",
				value))
		return
	}

	////
	// Parse ArrayOfDurations
	////

	value0, ok0 := cast[
		"array_of_durations"]

	if !ok0 {
		errors.Add(
			ref,
			"property is missing: array_of_durations")
	} else {
		cast1, ok1 := value0.([]interface{})
		if !ok1 {
			errors.Add(
				strings.Join(
					[]string{
						ref, "array_of_durations"},
					"/"),
				fmt.Sprintf(
					"expected a []interface{}, but got: %T",
					value0))
		} else {
			target1 := make(
				[]time.Duration,
				len(cast1))
			for i1 := range cast1 {
				cast2, ok2 := (cast1[i1]).(string)
				if !ok2 {
					errors.Add(
						strings.Join(
							[]string{
								ref, "array_of_durations", strconv.Itoa(i1)},
							"/"),
						fmt.Sprintf(
							"expected a string, but got: %T",
							cast1[i1]))
				} else {
					target2, err2 := durationFromString(cast2)
					if err2 != nil {
						errors.Add(
							strings.Join(
								[]string{
									ref, "array_of_durations", strconv.Itoa(i1)},
								"/"),
							fmt.Sprintf(
								"failed to parse duration from %#v: %s",
								cast2,
								err2.Error()))
					} else {
						target1[i1] = target2
					}
				}

				if errors.Full() {
					break;
				}
			}

			target.ArrayOfDurations = target1
		}
	}

	if errors.Full() {
		return
	}

	return
}

// File automatically generated by mapry. DO NOT EDIT OR APPEND!
