package somegraph

// File automatically generated by mapry. DO NOT EDIT OR APPEND!

import (
	"fmt"
	"regexp"
	"strconv"
	"strings"
)

var pattern0 = regexp.MustCompile(
	`^[a-zA-Z_\-][a-zA-Z_0-9\-]*$`)

// EmptyFromJSONable parses Empty from a JSONable value.
//
// If there are any errors, the state of the target is undefined.
//
// EmptyFromJSONable requires:
//  * target != nil
//  * errors != nil
//  * errors.Empty()
func EmptyFromJSONable(
	value interface{},
	id string,
	ref string,
	target *Empty,
	errors *Errors) {

	if target == nil {
		panic("unexpected nil target")
	}

	if errors == nil {
		panic("unexpected nil errors")
	}

	if !errors.Empty() {
		panic("unexpected non-empty errors")
	}

	_, ok := value.(map[string]interface{})
	if !ok {
		errors.Add(
			ref,
			fmt.Sprintf(
				"expected a map[string]interface{}, but got: %T",
				value))
		return
	}

	target.ID = id

	return
}

// WithReferenceFromJSONable parses WithReference from a JSONable value.
//
// If there are any errors, the state of the target is undefined.
//
// WithReferenceFromJSONable requires:
//  * target != nil
//  * errors != nil
//  * errors.Empty()
func WithReferenceFromJSONable(
	value interface{},
	id string,
	emptiesRegistry map[string]*Empty,
	ref string,
	target *WithReference,
	errors *Errors) {

	if target == nil {
		panic("unexpected nil target")
	}

	if errors == nil {
		panic("unexpected nil errors")
	}

	if !errors.Empty() {
		panic("unexpected non-empty errors")
	}

	cast, ok := value.(map[string]interface{})
	if !ok {
		errors.Add(
			ref,
			fmt.Sprintf(
				"expected a map[string]interface{}, but got: %T",
				value))
		return
	}

	target.ID = id

	////
	// Parse ReferenceToAnEmpty
	////

	value0, ok0 := cast[
		"reference_to_an_empty"]

	if !ok0 {
		errors.Add(
			ref,
			"property is missing: reference_to_an_empty")
	} else {
		cast1, ok1 := value0.(string)
		if !ok1 {
			errors.Add(
				strings.Join(
					[]string{
						ref, "reference_to_an_empty"},
					"/"),
				fmt.Sprintf(
					"expected a string, but got: %T",
					value0))
		} else {
			target1, ok1 := emptiesRegistry[cast1]
			if !ok1 {
				errors.Add(
					strings.Join(
						[]string{
							ref, "reference_to_an_empty"},
						"/"),
					fmt.Sprintf(
						"reference to an instance of class Empty not found: %s",
						value0))
			} else {
				target.ReferenceToAnEmpty = target1
			}
		}
	}

	if errors.Full() {
		return
	}

	////
	// Parse ArrayOfEmpties
	////

	value2, ok2 := cast[
		"array_of_empties"]

	if !ok2 {
		errors.Add(
			ref,
			"property is missing: array_of_empties")
	} else {
		cast3, ok3 := value2.([]interface{})
		if !ok3 {
			errors.Add(
				strings.Join(
					[]string{
						ref, "array_of_empties"},
					"/"),
				fmt.Sprintf(
					"expected a []interface{}, but got: %T",
					value2))
		} else {
			target3 := make(
				[]*Empty,
				len(cast3))
			for i3 := range cast3 {
				cast4, ok4 := (cast3[i3]).(string)
				if !ok4 {
					errors.Add(
						strings.Join(
							[]string{
								ref, "array_of_empties", strconv.Itoa(i3)},
							"/"),
						fmt.Sprintf(
							"expected a string, but got: %T",
							cast3[i3]))
				} else {
					target4, ok4 := emptiesRegistry[cast4]
					if !ok4 {
						errors.Add(
							strings.Join(
								[]string{
									ref, "array_of_empties", strconv.Itoa(i3)},
								"/"),
							fmt.Sprintf(
								"reference to an instance of class Empty not found: %s",
								cast3[i3]))
					} else {
						target3[i3] = target4
					}
				}

				if errors.Full() {
					break;
				}
			}

			target.ArrayOfEmpties = target3
		}
	}

	if errors.Full() {
		return
	}

	////
	// Parse MapOfEmpties
	////

	value5, ok5 := cast[
		"map_of_empties"]

	if !ok5 {
		errors.Add(
			ref,
			"property is missing: map_of_empties")
	} else {
		cast6, ok6 := value5.(map[string]interface{})
		if !ok6 {
			errors.Add(
				strings.Join(
					[]string{
						ref, "map_of_empties"},
					"/"),
				fmt.Sprintf(
					"expected a map[string]interface{}, but got: %T",
					value5))
		} else {
			target6 := make(map[string]*Empty)
			for k6 := range cast6 {
				cast7, ok7 := (cast6[k6]).(string)
				if !ok7 {
					errors.Add(
						strings.Join(
							[]string{
								ref, "map_of_empties", k6},
							"/"),
						fmt.Sprintf(
							"expected a string, but got: %T",
							cast6[k6]))
				} else {
					target7, ok7 := emptiesRegistry[cast7]
					if !ok7 {
						errors.Add(
							strings.Join(
								[]string{
									ref, "map_of_empties", k6},
								"/"),
							fmt.Sprintf(
								"reference to an instance of class Empty not found: %s",
								cast6[k6]))
					} else {
						target6[k6] = target7
					}
				}

				if errors.Full() {
					break;
				}
			}

			target.MapOfEmpties = target6
		}
	}

	if errors.Full() {
		return
	}

	return
}

// SomeGraphFromJSONable parses SomeGraph from a JSONable value.
//
// If there are any errors, the state of target is undefined.
//
// SomeGraphFromJSONable requires:
//  * target != nil
//  * errors != nil
//  * errors.Empty()
func SomeGraphFromJSONable(
	value interface{},
	ref string,
	target *SomeGraph,
	errors *Errors) {

	if target == nil {
		panic("unexpected nil target")
	}

	if errors == nil {
		panic("unexpected nil errors")
	}

	if !errors.Empty() {
		panic("unexpected non-empty errors")
	}

	cast, ok := value.(map[string]interface{})
	if !ok {
		errors.Add(
			ref,
			fmt.Sprintf(
				"expected a map[string]interface{}, but got: %T",
				value))
		return
	}

	////
	// Pre-allocate Empties
	////

	emptiesRef := ref+"/empties";
	var emptiesOk bool
	var emptiesValue interface{}
	var emptiesMap map[string]interface{}

	emptiesValue, emptiesOk = cast[
		"empties"]
	if emptiesOk {
		emptiesMap, ok = emptiesValue.(map[string]interface{})
		if !ok {
			errors.Add(
				emptiesRef,
				fmt.Sprintf(
					"expected a map[string]interface{}, but got: %T",
					emptiesValue));
		} else {
			target.Empties = make(
				map[string]*Empty)

			for id := range emptiesMap {
				if !pattern0.MatchString(id) {
					errors.Add(
						emptiesRef,
						fmt.Sprintf(
							"expected ID to match ^[a-zA-Z_\\-][a-zA-Z_0-9\\-]*$, but got: %s",
							id))
				} else {
					target.Empties[id] = &Empty{}
				}
			}
		}
	}

	////
	// Pre-allocate WithReferences
	////

	withReferencesRef := ref+"/with_references";
	var withReferencesOk bool
	var withReferencesValue interface{}
	var withReferencesMap map[string]interface{}

	withReferencesValue, withReferencesOk = cast[
		"with_references"]
	if withReferencesOk {
		withReferencesMap, ok = withReferencesValue.(map[string]interface{})
		if !ok {
			errors.Add(
				withReferencesRef,
				fmt.Sprintf(
					"expected a map[string]interface{}, but got: %T",
					withReferencesValue));
		} else {
			target.WithReferences = make(
				map[string]*WithReference)

			for id := range withReferencesMap {
				target.WithReferences[id] = &WithReference{}
			}
		}
	}

	// Pre-allocating class instances is critical.
	// If the pre-allocation failed, we can not continue to parse the instances.
	if !errors.Empty() {
		return
	}

	////
	// Parse Empties
	////

	if emptiesOk {
		for id, value := range emptiesMap {
			EmptyFromJSONable(
				value,
				id,
				strings.Join([]string{
					emptiesRef, id}, "/"),
				target.Empties[id],
				errors)

			if errors.Full() {
				break
			}
		}
	}

	if errors.Full() {
		return
	}

	////
	// Parse WithReferences
	////

	if withReferencesOk {
		for id, value := range withReferencesMap {
			WithReferenceFromJSONable(
				value,
				id,
				target.Empties,
				strings.Join([]string{
					withReferencesRef, id}, "/"),
				target.WithReferences[id],
				errors)

			if errors.Full() {
				break
			}
		}
	}

	if errors.Full() {
		return
	}

	////
	// Parse GlobalReferenceToAnEmpty
	////

	value0, ok0 := cast[
		"global_reference_to_an_empty"]

	if !ok0 {
		errors.Add(
			ref,
			"property is missing: global_reference_to_an_empty")
	} else {
		cast1, ok1 := value0.(string)
		if !ok1 {
			errors.Add(
				strings.Join(
					[]string{
						ref, "global_reference_to_an_empty"},
					"/"),
				fmt.Sprintf(
					"expected a string, but got: %T",
					value0))
		} else {
			target1, ok1 := target.Empties[cast1]
			if !ok1 {
				errors.Add(
					strings.Join(
						[]string{
							ref, "global_reference_to_an_empty"},
						"/"),
					fmt.Sprintf(
						"reference to an instance of class Empty not found: %s",
						value0))
			} else {
				target.GlobalReferenceToAnEmpty = target1
			}
		}
	}

	if errors.Full() {
		return
	}

	return
}

// File automatically generated by mapry. DO NOT EDIT OR APPEND!
