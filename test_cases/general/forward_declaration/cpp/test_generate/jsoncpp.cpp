// File automatically generated by mapry. DO NOT EDIT OR APPEND!

#include "jsoncpp.h"
#include "parse.h"
#include "types.h"

#include <cstring>
#include <memory>
#include <sstream>
#include <stdexcept>
#include <string>
#include <utility>

namespace some {
namespace graph {

namespace jsoncpp {

/**
 * generates an error message.
 *
 * @param cc char array as the description part of the message
 * @param cc_size size of the char array
 * @param s string as the detail part of the message
 * @return concatenated string
 */
std::string message(const char* cc, size_t cc_size, std::string s) {
  std::string result;
  result.reserve(cc_size + s.size());
  result.append(cc, cc_size);
  result.append(s);
  return result;
}

/**
 * converts a JSON value type to a human-readable string representation.
 *
 * @param value_type to be converted
 * @return string representation of the JSON value type
 */
std::string value_type_to_string(Json::ValueType value_type) {
  switch (value_type) {
    case Json::ValueType::nullValue: return "null";
    case Json::ValueType::intValue: return "int";
    case Json::ValueType::uintValue: return "uint";
    case Json::ValueType::realValue: return "real";
    case Json::ValueType::stringValue: return "string";
    case Json::ValueType::booleanValue: return "bool";
    case Json::ValueType::arrayValue: return "array";
    case Json::ValueType::objectValue: return "object";
    default:
      std::stringstream ss;
      ss << "Unhandled value type in value_to_string: "
        << value_type;
      throw std::domain_error(ss.str());
  }
}

void some_graph_from(
    const Json::Value& value,
    std::string ref,
    SomeGraph* target,
    parse::Errors* errors) {
  if (errors == nullptr) {
    throw std::invalid_argument("Unexpected null errors");
  }

  if (!errors->empty()) {
    throw std::invalid_argument("Unexpected non-empty errors");
  }

  if (!value.isObject()) {
    constexpr auto expected_but_got(
      "Expected an object, but got: ");

    errors->add(
      ref,
      message(
        expected_but_got,
        strlen(expected_but_got),
        value_type_to_string(
          value.type())));
    return;
  }

  ////
  // Pre-allocate some_classes
  ////

  std::string some_classes_ref;
  some_classes_ref.reserve(ref.size() + 13);
  some_classes_ref += ref;
  some_classes_ref += "/some_classes";

  if (value.isMember("some_classes")) {
    const Json::Value& obj = value["some_classes"];
    if (!obj.isObject()) {
      constexpr auto expected_but_got(
        "Expected an object, but got: ");

      errors->add(
        some_classes_ref,
        message(
          expected_but_got,
          strlen(expected_but_got),
          value_type_to_string(
            obj.type())));
    } else {
      for (Json::ValueConstIterator it = obj.begin();
          it != obj.end(); ++it) {
                auto instance = std::make_unique<SomeClass>();
        instance->id = it.name();
        target->some_classes[it.name()] = std::move(instance);

      }
    }
  }

  ////
  // Pre-allocate other_classes
  ////

  std::string other_classes_ref;
  other_classes_ref.reserve(ref.size() + 14);
  other_classes_ref += ref;
  other_classes_ref += "/other_classes";

  if (value.isMember("other_classes")) {
    const Json::Value& obj = value["other_classes"];
    if (!obj.isObject()) {
      constexpr auto expected_but_got(
        "Expected an object, but got: ");

      errors->add(
        other_classes_ref,
        message(
          expected_but_got,
          strlen(expected_but_got),
          value_type_to_string(
            obj.type())));
    } else {
      for (Json::ValueConstIterator it = obj.begin();
          it != obj.end(); ++it) {
                auto instance = std::make_unique<OtherClass>();
        instance->id = it.name();
        target->other_classes[it.name()] = std::move(instance);

      }
    }
  }

  // Pre-allocating class instances is critical.
  // If the pre-allocation failed, we can not continue to parse the instances.
  if (!errors->empty()) {
    return;
  }

  // Keep the prefix fixed in this buffer so that
  // it is copied as little as possible
  std::string instance_ref;

  ////
  // Parse some_classes
  ////

  // clear() does not shrink the reserved memory,
  // see https://en.cppreference.com/w/cpp/string/basic_string/clear
  instance_ref.clear();
  instance_ref += some_classes_ref;
  instance_ref += '/';

  if (value.isMember("some_classes")) {
    const Json::Value& obj = value["some_classes"];

    for (Json::ValueConstIterator it = obj.begin(); it != obj.end(); ++it) {
      instance_ref.reserve(
        some_classes_ref.size() + 1 + it.name().size());
      instance_ref.resize(
        some_classes_ref.size() + 1);
      instance_ref.append(
        it.name());

      SomeClass* instance(
        target->some_classes.at(it.name()).get());
      some_class_from(
        *it,
        target->other_classes,
        target->some_classes,
        instance_ref,
        instance,
        errors);

      if (errors->full()) {
        break;
      }
    }
  }
  if (errors->full()) {
    return;
  }

  ////
  // Parse other_classes
  ////

  // clear() does not shrink the reserved memory,
  // see https://en.cppreference.com/w/cpp/string/basic_string/clear
  instance_ref.clear();
  instance_ref += other_classes_ref;
  instance_ref += '/';

  if (value.isMember("other_classes")) {
    const Json::Value& obj = value["other_classes"];

    for (Json::ValueConstIterator it = obj.begin(); it != obj.end(); ++it) {
      instance_ref.reserve(
        other_classes_ref.size() + 1 + it.name().size());
      instance_ref.resize(
        other_classes_ref.size() + 1);
      instance_ref.append(
        it.name());

      OtherClass* instance(
        target->other_classes.at(it.name()).get());
      other_class_from(
        *it,
        target->other_classes,
        target->some_classes,
        instance_ref,
        instance,
        errors);

      if (errors->full()) {
        break;
      }
    }
  }
  if (errors->full()) {
    return;
  }
}

void some_class_from(
    const Json::Value& value,
    const std::map<std::string, std::unique_ptr<OtherClass>>& other_classes_registry,
    const std::map<std::string, std::unique_ptr<SomeClass>>& some_classes_registry,
    std::string ref,
    SomeClass* target,
    parse::Errors* errors) {
  if (!value.isObject()) {
    constexpr auto expected_but_got(
      "Expected an object, but got: ");

    errors->add(
      ref,
      message(
        expected_but_got,
        strlen(expected_but_got),
        value_type_to_string(
          value.type())));
    return;
  }

  ////
  // Parse reference_other
  ////

  if (!value.isMember("reference_other")) {
    errors->add(
      ref,
      "Property is missing: reference_other");
  } else {
    const Json::Value& value_0 = value["reference_other"];
    if (!value_0.isString()) {
      constexpr auto expected_but_got(
        "Expected a string, but got: ");

      errors->add(
        std::string(ref)
          .append("/reference_other"),
        message(
          expected_but_got,
          strlen(expected_but_got),
          value_type_to_string(
            value_0.type())));
    } else {
      const std::string& cast_0 = value_0.asString();
      if (other_classes_registry.count(cast_0) == 0) {
        constexpr auto reference_not_found(
          "Reference to an instance of class "
          "Other_class"
          " not found: ");

        errors->add(
          std::string(ref)
            .append("/reference_other"),
          message(
            reference_not_found,
            strlen(reference_not_found),
            cast_0));
      } else {
        target->reference_other = other_classes_registry.at(cast_0).get();
      }
    }
  }
  if (errors->full()) {
    return;
  }

  ////
  // Parse array_of_others
  ////

  if (!value.isMember("array_of_others")) {
    errors->add(
      ref,
      "Property is missing: array_of_others");
  } else {
    const Json::Value& value_1 = value["array_of_others"];
    if (!value_1.isArray()) {
      constexpr auto expected_but_got(
        "Expected an array, but got: ");

      errors->add(
        std::string(ref)
          .append("/array_of_others"),
        message(
          expected_but_got,
          strlen(expected_but_got),
          value_type_to_string(
            value_1.type())));
    } else {
      std::vector<OtherClass*>& target_1 = target->array_of_others;
      target_1.resize(value_1.size());
      size_t i_1 = 0;
      for (const Json::Value& item_1 : value_1) {
        if (!item_1.isString()) {
          constexpr auto expected_but_got(
            "Expected a string, but got: ");

          errors->add(
            std::string(ref)
              .append("/array_of_others")
              .append("/")
              .append(std::to_string(i_1)),
            message(
              expected_but_got,
              strlen(expected_but_got),
              value_type_to_string(
                item_1.type())));
        } else {
          const std::string& cast_2 = item_1.asString();
          if (other_classes_registry.count(cast_2) == 0) {
            constexpr auto reference_not_found(
              "Reference to an instance of class "
              "Other_class"
              " not found: ");

            errors->add(
              std::string(ref)
                .append("/array_of_others")
                .append("/")
                .append(std::to_string(i_1)),
              message(
                reference_not_found,
                strlen(reference_not_found),
                cast_2));
          } else {
            target_1.at(i_1) = other_classes_registry.at(cast_2).get();
          }
        }
        ++i_1;

        if (errors->full()) {
          break;
        }
      }

    }
  }
  if (errors->full()) {
    return;
  }

  ////
  // Parse map_of_others
  ////

  if (!value.isMember("map_of_others")) {
    errors->add(
      ref,
      "Property is missing: map_of_others");
  } else {
    const Json::Value& value_3 = value["map_of_others"];
    if (!value_3.isObject()) {
      constexpr auto expected_but_got(
        "Expected an object, but got: ");

      errors->add(
        std::string(ref)
          .append("/map_of_others"),
        message(
          expected_but_got,
          strlen(expected_but_got),
          value_type_to_string(
            value_3.type())));
    } else {
      std::map<std::string, OtherClass*>& target_3 = target->map_of_others;
      for (Json::ValueConstIterator it_3 = value_3.begin(); it_3 != value_3.end(); ++it_3) {
        const Json::Value& value_4 = *it_3;
        if (!value_4.isString()) {
          constexpr auto expected_but_got(
            "Expected a string, but got: ");

          errors->add(
            std::string(ref)
              .append("/map_of_others")
              .append("/")
              .append(it_3.name()),
            message(
              expected_but_got,
              strlen(expected_but_got),
              value_type_to_string(
                value_4.type())));
        } else {
          const std::string& cast_4 = value_4.asString();
          if (other_classes_registry.count(cast_4) == 0) {
            constexpr auto reference_not_found(
              "Reference to an instance of class "
              "Other_class"
              " not found: ");

            errors->add(
              std::string(ref)
                .append("/map_of_others")
                .append("/")
                .append(it_3.name()),
              message(
                reference_not_found,
                strlen(reference_not_found),
                cast_4));
          } else {
            target_3[it_3.name()] = other_classes_registry.at(cast_4).get();
          }
        }

        if (errors->full()) {
          break;
        }
      }
    }
  }
  if (errors->full()) {
    return;
  }
}

void other_class_from(
    const Json::Value& value,
    const std::map<std::string, std::unique_ptr<OtherClass>>& other_classes_registry,
    const std::map<std::string, std::unique_ptr<SomeClass>>& some_classes_registry,
    std::string ref,
    OtherClass* target,
    parse::Errors* errors) {
  if (!value.isObject()) {
    constexpr auto expected_but_got(
      "Expected an object, but got: ");

    errors->add(
      ref,
      message(
        expected_but_got,
        strlen(expected_but_got),
        value_type_to_string(
          value.type())));
    return;
  }

  ////
  // Parse reference_some
  ////

  if (!value.isMember("reference_some")) {
    errors->add(
      ref,
      "Property is missing: reference_some");
  } else {
    const Json::Value& value_0 = value["reference_some"];
    if (!value_0.isString()) {
      constexpr auto expected_but_got(
        "Expected a string, but got: ");

      errors->add(
        std::string(ref)
          .append("/reference_some"),
        message(
          expected_but_got,
          strlen(expected_but_got),
          value_type_to_string(
            value_0.type())));
    } else {
      const std::string& cast_0 = value_0.asString();
      if (some_classes_registry.count(cast_0) == 0) {
        constexpr auto reference_not_found(
          "Reference to an instance of class "
          "Some_class"
          " not found: ");

        errors->add(
          std::string(ref)
            .append("/reference_some"),
          message(
            reference_not_found,
            strlen(reference_not_found),
            cast_0));
      } else {
        target->reference_some = some_classes_registry.at(cast_0).get();
      }
    }
  }
  if (errors->full()) {
    return;
  }

  ////
  // Parse array_of_somes
  ////

  if (!value.isMember("array_of_somes")) {
    errors->add(
      ref,
      "Property is missing: array_of_somes");
  } else {
    const Json::Value& value_1 = value["array_of_somes"];
    if (!value_1.isArray()) {
      constexpr auto expected_but_got(
        "Expected an array, but got: ");

      errors->add(
        std::string(ref)
          .append("/array_of_somes"),
        message(
          expected_but_got,
          strlen(expected_but_got),
          value_type_to_string(
            value_1.type())));
    } else {
      std::vector<SomeClass*>& target_1 = target->array_of_somes;
      target_1.resize(value_1.size());
      size_t i_1 = 0;
      for (const Json::Value& item_1 : value_1) {
        if (!item_1.isString()) {
          constexpr auto expected_but_got(
            "Expected a string, but got: ");

          errors->add(
            std::string(ref)
              .append("/array_of_somes")
              .append("/")
              .append(std::to_string(i_1)),
            message(
              expected_but_got,
              strlen(expected_but_got),
              value_type_to_string(
                item_1.type())));
        } else {
          const std::string& cast_2 = item_1.asString();
          if (some_classes_registry.count(cast_2) == 0) {
            constexpr auto reference_not_found(
              "Reference to an instance of class "
              "Some_class"
              " not found: ");

            errors->add(
              std::string(ref)
                .append("/array_of_somes")
                .append("/")
                .append(std::to_string(i_1)),
              message(
                reference_not_found,
                strlen(reference_not_found),
                cast_2));
          } else {
            target_1.at(i_1) = some_classes_registry.at(cast_2).get();
          }
        }
        ++i_1;

        if (errors->full()) {
          break;
        }
      }

    }
  }
  if (errors->full()) {
    return;
  }

  ////
  // Parse map_of_somes
  ////

  if (!value.isMember("map_of_somes")) {
    errors->add(
      ref,
      "Property is missing: map_of_somes");
  } else {
    const Json::Value& value_3 = value["map_of_somes"];
    if (!value_3.isObject()) {
      constexpr auto expected_but_got(
        "Expected an object, but got: ");

      errors->add(
        std::string(ref)
          .append("/map_of_somes"),
        message(
          expected_but_got,
          strlen(expected_but_got),
          value_type_to_string(
            value_3.type())));
    } else {
      std::map<std::string, SomeClass*>& target_3 = target->map_of_somes;
      for (Json::ValueConstIterator it_3 = value_3.begin(); it_3 != value_3.end(); ++it_3) {
        const Json::Value& value_4 = *it_3;
        if (!value_4.isString()) {
          constexpr auto expected_but_got(
            "Expected a string, but got: ");

          errors->add(
            std::string(ref)
              .append("/map_of_somes")
              .append("/")
              .append(it_3.name()),
            message(
              expected_but_got,
              strlen(expected_but_got),
              value_type_to_string(
                value_4.type())));
        } else {
          const std::string& cast_4 = value_4.asString();
          if (some_classes_registry.count(cast_4) == 0) {
            constexpr auto reference_not_found(
              "Reference to an instance of class "
              "Some_class"
              " not found: ");

            errors->add(
              std::string(ref)
                .append("/map_of_somes")
                .append("/")
                .append(it_3.name()),
              message(
                reference_not_found,
                strlen(reference_not_found),
                cast_4));
          } else {
            target_3[it_3.name()] = some_classes_registry.at(cast_4).get();
          }
        }

        if (errors->full()) {
          break;
        }
      }
    }
  }
  if (errors->full()) {
    return;
  }
}

Json::Value serialize_some_class(
    const SomeClass& some_class) {
  Json::Value some_class_as_value;

  some_class_as_value["reference_other"] = some_class.reference_other->id;

  Json::Value target_0(Json::arrayValue);
  const auto& vector_0 = some_class.array_of_others;
  for (int i_0 = 0;
      i_0 < vector_0.size();
      ++i_0) {
    target_0[i_0] = vector_0[i_0]->id;
  }
  some_class_as_value["array_of_others"] = std::move(target_0);

  Json::Value target_1(Json::objectValue);
  const auto& map_1 = some_class.map_of_others;
  for (const auto& kv_1 : map_1) {
    target_1[kv_1.first] = kv_1.second->id;
  }
  some_class_as_value["map_of_others"] = std::move(target_1);

  return some_class_as_value;
}

Json::Value serialize_other_class(
    const OtherClass& other_class) {
  Json::Value other_class_as_value;

  other_class_as_value["reference_some"] = other_class.reference_some->id;

  Json::Value target_0(Json::arrayValue);
  const auto& vector_0 = other_class.array_of_somes;
  for (int i_0 = 0;
      i_0 < vector_0.size();
      ++i_0) {
    target_0[i_0] = vector_0[i_0]->id;
  }
  other_class_as_value["array_of_somes"] = std::move(target_0);

  Json::Value target_1(Json::objectValue);
  const auto& map_1 = other_class.map_of_somes;
  for (const auto& kv_1 : map_1) {
    target_1[kv_1.first] = kv_1.second->id;
  }
  other_class_as_value["map_of_somes"] = std::move(target_1);

  return other_class_as_value;
}

Json::Value serialize_some_graph(
    const SomeGraph& some_graph) {
  Json::Value some_graph_as_value;

  if (!some_graph.some_classes.empty()) {
    Json::Value some_classes_as_value;
    for (const auto& kv : some_graph.some_classes) {
      const std::string& id = kv.first;
      const SomeClass* instance = kv.second.get();

      if (id != instance->id) {
        constexpr auto expected(
          "Expected the class instance of "
          "SomeClass"
          "to have the ID ");
        constexpr auto but_got(", but got: ");

        std::string msg;
        msg.reserve(
          strlen(expected) + id.size() +
          strlen(but_got) + instance->id.size());
        msg += expected;
        msg += id;
        msg += but_got;
        msg += instance->id;

        throw std::invalid_argument(msg);
      }

      some_classes_as_value[instance->id] = serialize_some_class(*instance);
    }
    some_graph_as_value["some_classes"] = some_classes_as_value;
  }

  if (!some_graph.other_classes.empty()) {
    Json::Value other_classes_as_value;
    for (const auto& kv : some_graph.other_classes) {
      const std::string& id = kv.first;
      const OtherClass* instance = kv.second.get();

      if (id != instance->id) {
        constexpr auto expected(
          "Expected the class instance of "
          "OtherClass"
          "to have the ID ");
        constexpr auto but_got(", but got: ");

        std::string msg;
        msg.reserve(
          strlen(expected) + id.size() +
          strlen(but_got) + instance->id.size());
        msg += expected;
        msg += id;
        msg += but_got;
        msg += instance->id;

        throw std::invalid_argument(msg);
      }

      other_classes_as_value[instance->id] = serialize_other_class(*instance);
    }
    some_graph_as_value["other_classes"] = other_classes_as_value;
  }

  return some_graph_as_value;
}

}  // namespace jsoncpp

}  // namespace graph
}  // namespace some

// File automatically generated by mapry. DO NOT EDIT OR APPEND!
