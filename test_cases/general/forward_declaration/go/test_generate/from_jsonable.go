package somegraph

// File automatically generated by mapry. DO NOT EDIT OR APPEND!

import (
	"fmt"
	"strconv"
	"strings"
)

// SomeClassFromJSONable parses SomeClass from a JSONable value.
//
// If there are any errors, the state of the target is undefined.
//
// SomeClassFromJSONable requires:
//  * target != nil
//  * errors != nil
//  * errors.Empty()
func SomeClassFromJSONable(
	value interface{},
	id string,
	otherClassesRegistry map[string]*OtherClass,
	someClassesRegistry map[string]*SomeClass,
	ref string,
	target *SomeClass,
	errors *Errors) {

	if target == nil {
		panic("unexpected nil target")
	}

	if errors == nil {
		panic("unexpected nil errors")
	}

	if !errors.Empty() {
		panic("unexpected non-empty errors")
	}

	cast, ok := value.(map[string]interface{})
	if !ok {
		errors.Add(
			ref,
			fmt.Sprintf(
				"expected a map[string]interface{}, but got: %T",
				value))
		return
	}

	target.ID = id

	////
	// Parse ReferenceOther
	////

	value0, ok0 := cast[
		"reference_other"]

	if !ok0 {
		errors.Add(
			ref,
			"property is missing: reference_other")
	} else {
		cast1, ok1 := value0.(string)
		if !ok1 {
			errors.Add(
				strings.Join(
					[]string{
						ref, "reference_other"},
					"/"),
				fmt.Sprintf(
					"expected a string, but got: %T",
					value0))
		} else {
			target1, ok1 := otherClassesRegistry[cast1]
			if !ok1 {
				errors.Add(
					strings.Join(
						[]string{
							ref, "reference_other"},
						"/"),
					fmt.Sprintf(
						"reference to an instance of class OtherClass not found: %s",
						value0))
			} else {
				target.ReferenceOther = target1
			}
		}
	}

	if errors.Full() {
		return
	}

	////
	// Parse ArrayOfOthers
	////

	value2, ok2 := cast[
		"array_of_others"]

	if !ok2 {
		errors.Add(
			ref,
			"property is missing: array_of_others")
	} else {
		cast3, ok3 := value2.([]interface{})
		if !ok3 {
			errors.Add(
				strings.Join(
					[]string{
						ref, "array_of_others"},
					"/"),
				fmt.Sprintf(
					"expected a []interface{}, but got: %T",
					value2))
		} else {
			target3 := make(
				[]*OtherClass,
				len(cast3))
			for i3 := range cast3 {
				cast4, ok4 := (cast3[i3]).(string)
				if !ok4 {
					errors.Add(
						strings.Join(
							[]string{
								ref, "array_of_others", strconv.Itoa(i3)},
							"/"),
						fmt.Sprintf(
							"expected a string, but got: %T",
							cast3[i3]))
				} else {
					target4, ok4 := otherClassesRegistry[cast4]
					if !ok4 {
						errors.Add(
							strings.Join(
								[]string{
									ref, "array_of_others", strconv.Itoa(i3)},
								"/"),
							fmt.Sprintf(
								"reference to an instance of class OtherClass not found: %s",
								cast3[i3]))
					} else {
						target3[i3] = target4
					}
				}

				if errors.Full() {
					break;
				}
			}

			target.ArrayOfOthers = target3
		}
	}

	if errors.Full() {
		return
	}

	////
	// Parse MapOfOthers
	////

	value5, ok5 := cast[
		"map_of_others"]

	if !ok5 {
		errors.Add(
			ref,
			"property is missing: map_of_others")
	} else {
		cast6, ok6 := value5.(map[string]interface{})
		if !ok6 {
			errors.Add(
				strings.Join(
					[]string{
						ref, "map_of_others"},
					"/"),
				fmt.Sprintf(
					"expected a map[string]interface{}, but got: %T",
					value5))
		} else {
			target6 := make(map[string]*OtherClass)
			for k6 := range cast6 {
				cast7, ok7 := (cast6[k6]).(string)
				if !ok7 {
					errors.Add(
						strings.Join(
							[]string{
								ref, "map_of_others", k6},
							"/"),
						fmt.Sprintf(
							"expected a string, but got: %T",
							cast6[k6]))
				} else {
					target7, ok7 := otherClassesRegistry[cast7]
					if !ok7 {
						errors.Add(
							strings.Join(
								[]string{
									ref, "map_of_others", k6},
								"/"),
							fmt.Sprintf(
								"reference to an instance of class OtherClass not found: %s",
								cast6[k6]))
					} else {
						target6[k6] = target7
					}
				}

				if errors.Full() {
					break;
				}
			}

			target.MapOfOthers = target6
		}
	}

	if errors.Full() {
		return
	}

	return
}

// OtherClassFromJSONable parses OtherClass from a JSONable value.
//
// If there are any errors, the state of the target is undefined.
//
// OtherClassFromJSONable requires:
//  * target != nil
//  * errors != nil
//  * errors.Empty()
func OtherClassFromJSONable(
	value interface{},
	id string,
	otherClassesRegistry map[string]*OtherClass,
	someClassesRegistry map[string]*SomeClass,
	ref string,
	target *OtherClass,
	errors *Errors) {

	if target == nil {
		panic("unexpected nil target")
	}

	if errors == nil {
		panic("unexpected nil errors")
	}

	if !errors.Empty() {
		panic("unexpected non-empty errors")
	}

	cast, ok := value.(map[string]interface{})
	if !ok {
		errors.Add(
			ref,
			fmt.Sprintf(
				"expected a map[string]interface{}, but got: %T",
				value))
		return
	}

	target.ID = id

	////
	// Parse ReferenceSome
	////

	value0, ok0 := cast[
		"reference_some"]

	if !ok0 {
		errors.Add(
			ref,
			"property is missing: reference_some")
	} else {
		cast1, ok1 := value0.(string)
		if !ok1 {
			errors.Add(
				strings.Join(
					[]string{
						ref, "reference_some"},
					"/"),
				fmt.Sprintf(
					"expected a string, but got: %T",
					value0))
		} else {
			target1, ok1 := someClassesRegistry[cast1]
			if !ok1 {
				errors.Add(
					strings.Join(
						[]string{
							ref, "reference_some"},
						"/"),
					fmt.Sprintf(
						"reference to an instance of class SomeClass not found: %s",
						value0))
			} else {
				target.ReferenceSome = target1
			}
		}
	}

	if errors.Full() {
		return
	}

	////
	// Parse ArrayOfSomes
	////

	value2, ok2 := cast[
		"array_of_somes"]

	if !ok2 {
		errors.Add(
			ref,
			"property is missing: array_of_somes")
	} else {
		cast3, ok3 := value2.([]interface{})
		if !ok3 {
			errors.Add(
				strings.Join(
					[]string{
						ref, "array_of_somes"},
					"/"),
				fmt.Sprintf(
					"expected a []interface{}, but got: %T",
					value2))
		} else {
			target3 := make(
				[]*SomeClass,
				len(cast3))
			for i3 := range cast3 {
				cast4, ok4 := (cast3[i3]).(string)
				if !ok4 {
					errors.Add(
						strings.Join(
							[]string{
								ref, "array_of_somes", strconv.Itoa(i3)},
							"/"),
						fmt.Sprintf(
							"expected a string, but got: %T",
							cast3[i3]))
				} else {
					target4, ok4 := someClassesRegistry[cast4]
					if !ok4 {
						errors.Add(
							strings.Join(
								[]string{
									ref, "array_of_somes", strconv.Itoa(i3)},
								"/"),
							fmt.Sprintf(
								"reference to an instance of class SomeClass not found: %s",
								cast3[i3]))
					} else {
						target3[i3] = target4
					}
				}

				if errors.Full() {
					break;
				}
			}

			target.ArrayOfSomes = target3
		}
	}

	if errors.Full() {
		return
	}

	////
	// Parse MapOfSomes
	////

	value5, ok5 := cast[
		"map_of_somes"]

	if !ok5 {
		errors.Add(
			ref,
			"property is missing: map_of_somes")
	} else {
		cast6, ok6 := value5.(map[string]interface{})
		if !ok6 {
			errors.Add(
				strings.Join(
					[]string{
						ref, "map_of_somes"},
					"/"),
				fmt.Sprintf(
					"expected a map[string]interface{}, but got: %T",
					value5))
		} else {
			target6 := make(map[string]*SomeClass)
			for k6 := range cast6 {
				cast7, ok7 := (cast6[k6]).(string)
				if !ok7 {
					errors.Add(
						strings.Join(
							[]string{
								ref, "map_of_somes", k6},
							"/"),
						fmt.Sprintf(
							"expected a string, but got: %T",
							cast6[k6]))
				} else {
					target7, ok7 := someClassesRegistry[cast7]
					if !ok7 {
						errors.Add(
							strings.Join(
								[]string{
									ref, "map_of_somes", k6},
								"/"),
							fmt.Sprintf(
								"reference to an instance of class SomeClass not found: %s",
								cast6[k6]))
					} else {
						target6[k6] = target7
					}
				}

				if errors.Full() {
					break;
				}
			}

			target.MapOfSomes = target6
		}
	}

	if errors.Full() {
		return
	}

	return
}

// SomeGraphFromJSONable parses SomeGraph from a JSONable value.
//
// If there are any errors, the state of target is undefined.
//
// SomeGraphFromJSONable requires:
//  * target != nil
//  * errors != nil
//  * errors.Empty()
func SomeGraphFromJSONable(
	value interface{},
	ref string,
	target *SomeGraph,
	errors *Errors) {

	if target == nil {
		panic("unexpected nil target")
	}

	if errors == nil {
		panic("unexpected nil errors")
	}

	if !errors.Empty() {
		panic("unexpected non-empty errors")
	}

	cast, ok := value.(map[string]interface{})
	if !ok {
		errors.Add(
			ref,
			fmt.Sprintf(
				"expected a map[string]interface{}, but got: %T",
				value))
		return
	}

	////
	// Pre-allocate SomeClasses
	////

	someClassesRef := ref+"/some_classes";
	var someClassesOk bool
	var someClassesValue interface{}
	var someClassesMap map[string]interface{}

	someClassesValue, someClassesOk = cast[
		"some_classes"]
	if someClassesOk {
		someClassesMap, ok = someClassesValue.(map[string]interface{})
		if !ok {
			errors.Add(
				someClassesRef,
				fmt.Sprintf(
					"expected a map[string]interface{}, but got: %T",
					someClassesValue));
		} else {
			target.SomeClasses = make(
				map[string]*SomeClass)

			for id := range someClassesMap {
				target.SomeClasses[id] = &SomeClass{}
			}
		}
	}

	////
	// Pre-allocate OtherClasses
	////

	otherClassesRef := ref+"/other_classes";
	var otherClassesOk bool
	var otherClassesValue interface{}
	var otherClassesMap map[string]interface{}

	otherClassesValue, otherClassesOk = cast[
		"other_classes"]
	if otherClassesOk {
		otherClassesMap, ok = otherClassesValue.(map[string]interface{})
		if !ok {
			errors.Add(
				otherClassesRef,
				fmt.Sprintf(
					"expected a map[string]interface{}, but got: %T",
					otherClassesValue));
		} else {
			target.OtherClasses = make(
				map[string]*OtherClass)

			for id := range otherClassesMap {
				target.OtherClasses[id] = &OtherClass{}
			}
		}
	}

	// Pre-allocating class instances is critical.
	// If the pre-allocation failed, we can not continue to parse the instances.
	if !errors.Empty() {
		return
	}

	////
	// Parse SomeClasses
	////

	if someClassesOk {
		for id, value := range someClassesMap {
			SomeClassFromJSONable(
				value,
				id,
				target.OtherClasses,
				target.SomeClasses,
				strings.Join([]string{
					someClassesRef, id}, "/"),
				target.SomeClasses[id],
				errors)

			if errors.Full() {
				break
			}
		}
	}

	if errors.Full() {
		return
	}

	////
	// Parse OtherClasses
	////

	if otherClassesOk {
		for id, value := range otherClassesMap {
			OtherClassFromJSONable(
				value,
				id,
				target.OtherClasses,
				target.SomeClasses,
				strings.Join([]string{
					otherClassesRef, id}, "/"),
				target.OtherClasses[id],
				errors)

			if errors.Full() {
				break
			}
		}
	}

	if errors.Full() {
		return
	}

	return
}

// File automatically generated by mapry. DO NOT EDIT OR APPEND!
