// File automatically generated by mapry. DO NOT EDIT OR APPEND!

#include "jsoncpp.h"
#include "parse.h"
#include "types.h"

#include <cstring>
#include <memory>
#include <sstream>
#include <stdexcept>
#include <string>
#include <utility>

namespace some {
namespace graph {

namespace jsoncpp {

/**
 * generates an error message.
 *
 * @param cc char array as the description part of the message
 * @param cc_size size of the char array
 * @param s string as the detail part of the message
 * @return concatenated string
 */
std::string message(const char* cc, size_t cc_size, std::string s) {
  std::string result;
  result.reserve(cc_size + s.size());
  result.append(cc, cc_size);
  result.append(s);
  return result;
}

/**
 * converts a JSON value type to a human-readable string representation.
 *
 * @param value_type to be converted
 * @return string representation of the JSON value type
 */
std::string value_type_to_string(Json::ValueType value_type) {
  switch (value_type) {
    case Json::ValueType::nullValue: return "null";
    case Json::ValueType::intValue: return "int";
    case Json::ValueType::uintValue: return "uint";
    case Json::ValueType::realValue: return "real";
    case Json::ValueType::stringValue: return "string";
    case Json::ValueType::booleanValue: return "bool";
    case Json::ValueType::arrayValue: return "array";
    case Json::ValueType::objectValue: return "object";
    default:
      std::stringstream ss;
      ss << "Unhandled value type in value_to_string: "
        << value_type;
      throw std::domain_error(ss.str());
  }
}

void some_graph_from(
    const Json::Value& value,
    std::string ref,
    SomeGraph* target,
    parse::Errors* errors) {
  if (errors == nullptr) {
    throw std::invalid_argument("Unexpected null errors");
  }

  if (not errors->empty()) {
    throw std::invalid_argument("Unexpected non-empty errors");
  }

  if (not value.isObject()) {
    constexpr auto expected_but_got(
      "Expected an object, but got: ");

    errors->add(
      ref,
      message(
        expected_but_got,
        strlen(expected_but_got),
        value_type_to_string(
          value.type())));
    return;
  }

  ////
  // Parse some_map
  ////

  if (not value.isMember("some_map")) {
    errors->add(
      ref,
      "Property is missing: some_map");
  } else {
    const Json::Value& value_0 = value["some_map"];
    if (not value_0.isObject()) {
      constexpr auto expected_but_got(
        "Expected an object, but got: ");

      errors->add(
        std::string(ref)
          .append("/some_map"),
        message(
          expected_but_got,
          strlen(expected_but_got),
          value_type_to_string(
            value_0.type())));
    } else {
      std::map<std::string, int64_t>& target_0 = target->some_map;
      for (Json::ValueConstIterator it_0 = value_0.begin(); it_0 != value_0.end(); ++it_0) {
        const Json::Value& value_1 = *it_0;
        if (not value_1.isInt64()) {
          constexpr auto expected_but_got(
            "Expected an int64, but got: ");

          errors->add(
            std::string(ref)
              .append("/some_map")
              .append("/")
              .append(it_0.name()),
            message(
              expected_but_got,
              strlen(expected_but_got),
              value_type_to_string(
                value_1.type())));
        } else {
          const auto cast_1 = value_1.asInt64();
          bool ok_1 = true;

          if (not (cast_1 >= 0)) {
            constexpr auto expected_but_got(
              "Expected "
              ">= 0"
              ", but got: ");

            errors->add(
              std::string(ref)
                .append("/some_map")
                .append("/")
                .append(it_0.name()),
              message(
                expected_but_got,
                strlen(expected_but_got),
                std::to_string(cast_1)));
            ok_1 = false;
          }

          if (ok_1) {
            target_0[it_0.name()] = cast_1;
          }
        }

        if (errors->full()) {
          break;
        }
      }
    }
  }
  if (errors->full()) {
    return;
  }

  ////
  // Parse some_nested_map
  ////

  if (not value.isMember("some_nested_map")) {
    errors->add(
      ref,
      "Property is missing: some_nested_map");
  } else {
    const Json::Value& value_2 = value["some_nested_map"];
    if (not value_2.isObject()) {
      constexpr auto expected_but_got(
        "Expected an object, but got: ");

      errors->add(
        std::string(ref)
          .append("/some_nested_map"),
        message(
          expected_but_got,
          strlen(expected_but_got),
          value_type_to_string(
            value_2.type())));
    } else {
      std::map<std::string, std::map<std::string, int64_t>>& target_2 = target->some_nested_map;
      for (Json::ValueConstIterator it_2 = value_2.begin(); it_2 != value_2.end(); ++it_2) {
        const Json::Value& value_3 = *it_2;
        if (not value_3.isObject()) {
          constexpr auto expected_but_got(
            "Expected an object, but got: ");

          errors->add(
            std::string(ref)
              .append("/some_nested_map")
              .append("/")
              .append(it_2.name()),
            message(
              expected_but_got,
              strlen(expected_but_got),
              value_type_to_string(
                value_3.type())));
        } else {
          std::map<std::string, int64_t>& target_3 = target_2[it_2.name()];
          for (Json::ValueConstIterator it_3 = value_3.begin(); it_3 != value_3.end(); ++it_3) {
            const Json::Value& value_4 = *it_3;
            if (not value_4.isInt64()) {
              constexpr auto expected_but_got(
                "Expected an int64, but got: ");

              errors->add(
                std::string(ref)
                  .append("/some_nested_map")
                  .append("/")
                  .append(it_2.name())
                  .append("/")
                  .append(it_3.name()),
                message(
                  expected_but_got,
                  strlen(expected_but_got),
                  value_type_to_string(
                    value_4.type())));
            } else {
              const auto cast_4 = value_4.asInt64();
              bool ok_4 = true;

              if (not (cast_4 >= 0)) {
                constexpr auto expected_but_got(
                  "Expected "
                  ">= 0"
                  ", but got: ");

                errors->add(
                  std::string(ref)
                    .append("/some_nested_map")
                    .append("/")
                    .append(it_2.name())
                    .append("/")
                    .append(it_3.name()),
                  message(
                    expected_but_got,
                    strlen(expected_but_got),
                    std::to_string(cast_4)));
                ok_4 = false;
              }

              if (ok_4) {
                target_3[it_3.name()] = cast_4;
              }
            }

            if (errors->full()) {
              break;
            }
          }
        }

        if (errors->full()) {
          break;
        }
      }
    }
  }
  if (errors->full()) {
    return;
  }
}

Json::Value serialize_some_graph(
    const SomeGraph& some_graph) {
  Json::Value some_graph_as_value;

  Json::Value target_0(Json::objectValue);
  const auto& map_0 = some_graph.some_map;
  for (const auto& kv_0 : map_0) {
    target_0[kv_0.first] = kv_0.second;
  }
  some_graph_as_value["some_map"] = std::move(target_0);

  Json::Value target_1(Json::objectValue);
  const auto& map_1 = some_graph.some_nested_map;
  for (const auto& kv_1 : map_1) {
    Json::Value target_2(Json::objectValue);
    const auto& map_2 = kv_1.second;
    for (const auto& kv_2 : map_2) {
      target_2[kv_2.first] = kv_2.second;
    }
    target_1[kv_1.first] = std::move(target_2);
  }
  some_graph_as_value["some_nested_map"] = std::move(target_1);

  return some_graph_as_value;
}

}  // namespace jsoncpp

}  // namespace graph
}  // namespace some

// File automatically generated by mapry. DO NOT EDIT OR APPEND!
