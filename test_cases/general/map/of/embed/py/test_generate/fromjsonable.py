# File automatically generated by mapry. DO NOT EDIT OR APPEND!


"""parses JSONable objects."""


import collections
import typing

import some.graph
import some.graph.parse


def _someembed_from(
        value: typing.Any,
        ref: str,
        target: some.graph.SomeEmbed,
        errors: some.graph.parse.Errors
) -> None:
    """
    parses SomeEmbed from a JSONable value.

    If ``errors``, the attributes of ``target`` have undefined values.

    :param value: JSONable value
    :param ref:
        reference to the value (e.g., a reference path)
    :param target: parsed ``value`` as SomeEmbed
    :param errors: errors encountered during parsing
    :return:

    """
    if not isinstance(value, dict):
        errors.add(
            ref,
            "Expected a dictionary, but got: {}".format(
                type(value)))
        return

    ##
    # Parse some_property
    ##

    value_0 = value.get(
        'some_property',
        None)

    if value_0 is None:
        errors.add(
            ref,
            'Property is missing: some_property')
    else:
        if not isinstance(value_0, bool):
            errors.add(
                '/'.join((
                    ref, 'some_property')),
                "Expected a bool, but got: {}".format(
                    type(value_0)))
        else:
            target.some_property = value_0
    if errors.full():
        return


def someembed_from(
        value: typing.Any,
        ref: str,
        errors: some.graph.parse.Errors
) -> typing.Optional[some.graph.SomeEmbed]:
    """
    parses SomeEmbed from a JSONable value.

    :param value: JSONable value
    :param id: identifier of the instance
    :param ref:
        reference to the value (e.g., a reference path)
    :param errors: errors encountered during parsing
    :return: parsed instance, or None if ``errors``

    """
    target = some.graph.parse.placeholder_someembed()

    _someembed_from(
        value=value,
        ref=ref,
        target=target,
        errors=errors)

    if not errors.empty():
       return None

    return target


def some_graph_from(
        value: typing.Any,
        ref: str,
        errors: some.graph.parse.Errors
) -> typing.Optional[some.graph.SomeGraph]:
    """
    parses SomeGraph from a JSONable value.

    :param value: JSONable value
    :param ref: reference to the value (e.g., a reference path)
    :param errors: errors encountered during parsing
    :return: parsed SomeGraph, or None if ``errors``
    """
    if errors.full():
        return None

    if not isinstance(value, dict):
        errors.add(
            ref,
            "Expected a dictionary, but got: {}".format(type(value)))
        return None

    graph = some.graph.parse.placeholder_some_graph()

    ##
    # Parse map_of_embeds
    ##

    value_0 = value.get(
        'map_of_embeds',
        None)

    if value_0 is None:
        errors.add(
            ref,
            'Property is missing: map_of_embeds')
    else:
        if not isinstance(value_0, dict):
            errors.add(
                '/'.join((
                    ref, 'map_of_embeds')),
                "Expected a dict, but got: {}".format(
                    type(value_0)))
        else:
            if isinstance(value_0, collections.OrderedDict):
                target_1 = (
                    collections.OrderedDict()
                )  # type: typing.MutableMapping[str, some.graph.SomeEmbed]
            else:
                target_1 = (
                    dict()
                )

            for key_1, value_1 in value_0.items():
                if not isinstance(key_1, str):
                    errors.add(
                        '/'.join((
                            ref, 'map_of_embeds')),
                        "Expected the key to be a str, but got: {}".format(
                            type(key_1)))

                    if errors.full():
                        break
                    else:
                        continue

                target_item_1 = (
                    None
                )  # type: typing.Optional[some.graph.SomeEmbed]
                target_2 = (
                    some.graph.parse.placeholder_someembed()
                )
                _someembed_from(
                    value_1,
                    '/'.join((
                        ref, 'map_of_embeds', repr(key_1))),
                    target_2,
                    errors)
                target_item_1 = target_2

                if target_item_1 is not None:
                    target_1[key_1] = target_item_1

                if errors.full():
                    break

            if target_1 is not None:
                graph.map_of_embeds = target_1

    if errors.full():
        return None

    if not errors.empty():
        return None

    return graph
