# File automatically generated by mapry. DO NOT EDIT OR APPEND!


"""parses JSONable objects."""


import collections
import typing

import some.graph
import some.graph.parse


def some_graph_from(
        value: typing.Any,
        ref: str,
        errors: some.graph.parse.Errors
) -> typing.Optional[some.graph.SomeGraph]:
    """
    parses SomeGraph from a JSONable value.

    :param value: JSONable value
    :param ref: reference to the value (e.g., a reference path)
    :param errors: errors encountered during parsing
    :return: parsed SomeGraph, or None if ``errors``
    """
    if errors.full():
        return None

    if not isinstance(value, dict):
        errors.add(
            ref,
            "Expected a dictionary, but got: {}".format(type(value)))
        return None

    graph = some.graph.parse.placeholder_some_graph()

    ##
    # Parse some_map
    ##

    value_0 = value.get(
        'some_map',
        None)

    if value_0 is None:
        errors.add(
            ref,
            'Property is missing: some_map')
    else:
        if not isinstance(value_0, dict):
            errors.add(
                '/'.join((
                    ref, 'some_map')),
                "Expected a dict, but got: {}".format(
                    type(value_0)))
        else:
            if isinstance(value_0, collections.OrderedDict):
                target_1 = (
                    collections.OrderedDict()
                )  # type: typing.MutableMapping[str, int]
            else:
                target_1 = (
                    dict()
                )

            for key_1, value_1 in value_0.items():
                if not isinstance(key_1, str):
                    errors.add(
                        '/'.join((
                            ref, 'some_map')),
                        "Expected the key to be a str, but got: {}".format(
                            type(key_1)))

                    if errors.full():
                        break
                    else:
                        continue

                target_item_1 = (
                    None
                )  # type: typing.Optional[int]
                if not isinstance(value_1, int):
                    errors.add(
                        '/'.join((
                            ref, 'some_map', repr(key_1))),
                        "Expected an integer, but got: {}".format(
                            type(value_1)))
                else:
                    if not (value_1 >= 0):
                        errors.add(
                            '/'.join((
                                ref, 'some_map', repr(key_1))),
                            'Expected >= 0, but got: {}'.format(
                                value_1))
                    else:
                        target_item_1 = value_1

                if target_item_1 is not None:
                    target_1[key_1] = target_item_1

                if errors.full():
                    break

            if target_1 is not None:
                graph.some_map = target_1

    if errors.full():
        return None

    ##
    # Parse some_nested_map
    ##

    value_3 = value.get(
        'some_nested_map',
        None)

    if value_3 is None:
        errors.add(
            ref,
            'Property is missing: some_nested_map')
    else:
        if not isinstance(value_3, dict):
            errors.add(
                '/'.join((
                    ref, 'some_nested_map')),
                "Expected a dict, but got: {}".format(
                    type(value_3)))
        else:
            if isinstance(value_3, collections.OrderedDict):
                target_4 = (
                    collections.OrderedDict()
                )  # type: typing.MutableMapping[str, typing.MutableMapping[str, int]]
            else:
                target_4 = (
                    dict()
                )

            for key_4, value_4 in value_3.items():
                if not isinstance(key_4, str):
                    errors.add(
                        '/'.join((
                            ref, 'some_nested_map')),
                        "Expected the key to be a str, but got: {}".format(
                            type(key_4)))

                    if errors.full():
                        break
                    else:
                        continue

                target_item_4 = (
                    None
                )  # type: typing.Optional[typing.MutableMapping[str, int]]
                if not isinstance(value_4, dict):
                    errors.add(
                        '/'.join((
                            ref, 'some_nested_map', repr(key_4))),
                        "Expected a dict, but got: {}".format(
                            type(value_4)))
                else:
                    if isinstance(value_4, collections.OrderedDict):
                        target_5 = (
                            collections.OrderedDict()
                        )  # type: typing.MutableMapping[str, int]
                    else:
                        target_5 = (
                            dict()
                        )

                    for key_5, value_5 in value_4.items():
                        if not isinstance(key_5, str):
                            errors.add(
                                '/'.join((
                                    ref, 'some_nested_map', repr(key_4))),
                                "Expected the key to be a str, but got: {}".format(
                                    type(key_5)))

                            if errors.full():
                                break
                            else:
                                continue

                        target_item_5 = (
                            None
                        )  # type: typing.Optional[int]
                        if not isinstance(value_5, int):
                            errors.add(
                                '/'.join((
                                    ref, 'some_nested_map', repr(key_4), repr(key_5))),
                                "Expected an integer, but got: {}".format(
                                    type(value_5)))
                        else:
                            if not (value_5 >= 0):
                                errors.add(
                                    '/'.join((
                                        ref, 'some_nested_map', repr(key_4), repr(key_5))),
                                    'Expected >= 0, but got: {}'.format(
                                        value_5))
                            else:
                                target_item_5 = value_5

                        if target_item_5 is not None:
                            target_5[key_5] = target_item_5

                        if errors.full():
                            break

                    if target_5 is not None:
                        target_item_4 = target_5

                if target_item_4 is not None:
                    target_4[key_4] = target_item_4

                if errors.full():
                    break

            if target_4 is not None:
                graph.some_nested_map = target_4

    if errors.full():
        return None

    if not errors.empty():
        return None

    return graph
