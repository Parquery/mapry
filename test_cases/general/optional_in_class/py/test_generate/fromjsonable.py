# File automatically generated by mapry. DO NOT EDIT OR APPEND!


"""parses JSONable objects."""


import collections
import typing

import some.graph
import some.graph.parse


def _with_optional_from(
        value: typing.Any,
        ref: str,
        target: some.graph.WithOptional,
        errors: some.graph.parse.Errors
) -> None:
    """
    parses WithOptional from a JSONable value.

    If ``errors``, the attributes of ``target`` have undefined values.

    :param value: JSONable value
    :param ref:
        reference to the value (e.g., a reference path)
    :param target: parsed ``value`` as WithOptional
    :param errors: errors encountered during parsing
    :return:

    """
    if not isinstance(value, dict):
        errors.add(
            ref,
            "Expected a dictionary, but got: {}".format(
                type(value)))
        return

    ##
    # Parse some_text
    ##

    value_0 = value.get(
        'some_text',
        None)

    if value_0 is not None:
        if not isinstance(value_0, str):
            errors.add(
                '/'.join((
                    ref, 'some_text')),
                "Expected a string, but got: {}".format(
                    type(value_0)))
        else:
            target.some_text = value_0
    if errors.full():
        return


def with_optional_from(
        value: typing.Any,
        id: str,
        ref: str,
        errors: some.graph.parse.Errors
) -> typing.Optional[some.graph.WithOptional]:
    """
    parses WithOptional from a JSONable value.

    :param value: JSONable value
    :param id: identifier of the instance
    :param ref:
        reference to the value (e.g., a reference path)
    :param errors: errors encountered during parsing
    :return: parsed instance, or None if ``errors``

    """
    target = some.graph.parse.placeholder_with_optional(id=id)

    _with_optional_from(
        value=value,
        ref=ref,
        target=target,
        errors=errors)

    if not errors.empty():
       return None

    return target


def some_graph_from(
        value: typing.Any,
        ref: str,
        errors: some.graph.parse.Errors
) -> typing.Optional[some.graph.SomeGraph]:
    """
    parses SomeGraph from a JSONable value.

    :param value: JSONable value
    :param ref: reference to the value (e.g., a reference path)
    :param errors: errors encountered during parsing
    :return: parsed SomeGraph, or None if ``errors``
    """
    if errors.full():
        return None

    if not isinstance(value, dict):
        errors.add(
            ref,
            "Expected a dictionary, but got: {}".format(type(value)))
        return None

    graph = some.graph.parse.placeholder_some_graph()

    ##
    # Pre-allocate with_optionals
    ##

    registry_value = value.get('with_optionals', None)

    if registry_value is not None:
        if not isinstance(registry_value, dict):
            errors.add(
                '/'.join((
                    ref, 'with_optionals')),
                "Expected a dictionary, but got: {}".format(
                    type(registry_value)))
        else:
            if isinstance(registry_value, collections.OrderedDict):
                graph.with_optionals = collections.OrderedDict()
            else:
                graph.with_optionals = dict()

            with_optionals_registry = graph.with_optionals
            for id in registry_value:
                with_optionals_registry[id] = some.graph.parse.placeholder_with_optional(id=id)

    if errors.full():
        return None

    # Errors from pre-allocation are considered critical.
    if not errors.empty():
        return None

    ##
    # Parse with_optionals
    ##

    if 'with_optionals' in value:
        registry_value = value['with_optionals']
        for id, instance_value in registry_value.items():
            target_with_optional = graph.with_optionals[id]
            target_with_optional.id = id

            _with_optional_from(
                instance_value,
                '/'.join((
                    ref, 'with_optionals', repr(id))),
                target_with_optional,
                errors)

            if errors.full():
                return None

    if not errors.empty():
        return None

    return graph
