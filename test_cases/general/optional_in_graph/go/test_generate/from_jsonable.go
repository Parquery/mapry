package somegraph

// File automatically generated by mapry. DO NOT EDIT OR APPEND!

import (
	"fmt"
	"math"
	"regexp"
	"strconv"
	"strings"
	"time"
)

var durationRe = regexp.MustCompile(
	`^(-|\+)?P`+
	`(((0|[1-9][0-9]*)(\.[0-9]+)?)Y)?`+
	`(((0|[1-9][0-9]*)(\.[0-9]+)?)M)?`+
	`(((0|[1-9][0-9]*)(\.[0-9]+)?)W)?`+
	`(((0|[1-9][0-9]*)(\.[0-9]+)?)D)?`+
	`(T`+
	`(((0|[1-9][0-9]*)(\.[0-9]+)?)H)?`+
	`(((0|[1-9][0-9]*)(\.[0-9]+)?)M)?`+
	`(((0|[1-9][0-9]*)(\.([0-9]+))?)S)?`+
	`)?$`)

// addDuration adds right nanoseconds to the left duration.
//
// addDurationInt64 requires:
//  * left >= 0
//  * right >= 0
func addDuration(
	left time.Duration,
	right float64) (result time.Duration, overflow bool) {

	if !(left >= 0) {
		panic("Expected left >= 0")
	}

	if !(right >= 0) {
		panic("Expected right >= 0")
	}

	// 9223372036854775808.0 == 2^63 is the first float > MaxInt64.
	if right >= 9223372036854775808.0 {
		overflow = true
		return
	}

	rightAsNs := time.Duration(right)
	if rightAsNs > math.MaxInt64 - left {
		overflow = true
		return
	}

	result = left + rightAsNs
	return
}

// durationFromString parses the duration as ISO 8601 format.
//
// Following C++ chrono library, the following units are counted as:
//  * years as 365.2425 days (the average length of a Gregorian year),
//  * months as 30.436875 days (exactly 1/12 of years) and
//  * weeks as 7 days.
//
// Since time.Duration is measured in nanoseconds, beware of overflow
// issues due to finite representation of integers.
func durationFromString(s string) (d time.Duration, err error) {
	m := durationRe.FindStringSubmatch(s)

	if len(m) == 0 {
		err = fmt.Errorf("failed to match the duration pattern")
		return
	}

	////
	// Interprete
	////

	var years, months, weeks, days, hours, minutes float64
	var seconds, nanoseconds int64

	sign := int64(1)
	if len(m[1]) > 0 && m[1][0] == '-' {
		sign = -1
	}

	if len(m[3]) > 0 {
		years, err = strconv.ParseFloat(m[3], 64)
		if err != nil {
			err = fmt.Errorf("failed to parse the years: %s", err.Error())
			return
		}
	}

	if len(m[7]) > 0 {
		months, err = strconv.ParseFloat(m[7], 64)
		if err != nil {
			err = fmt.Errorf("failed to parse the months: %s", err.Error())
			return
		}
	}

	if len(m[11]) > 0 {
		weeks, err = strconv.ParseFloat(m[11], 64)
		if err != nil {
			err = fmt.Errorf("failed to parse the weeks: %s", err.Error())
			return
		}
	}

	if len(m[15]) > 0 {
		days, err = strconv.ParseFloat(m[15], 64)
		if err != nil {
			err = fmt.Errorf("failed to parse the days: %s", err.Error())
			return
		}
	}

	if len(m[20]) > 0 {
		hours, err = strconv.ParseFloat(m[20], 64)
		if err != nil {
			err = fmt.Errorf("failed to parse the hours: %s", err.Error())
			return
		}
	}

	if len(m[24]) > 0 {
		minutes, err = strconv.ParseFloat(m[24], 64)
		if err != nil {
			err = fmt.Errorf("failed to parse the minutes: %s", err.Error())
			return
		}
	}

	if len(m[29]) > 0 {
		seconds, err = strconv.ParseInt(m[29], 10, 64)
		if err != nil {
			err = fmt.Errorf("failed to parse the seconds: %s", err.Error())
			return
		}
	}

	switch {
	case len(m[31]) == 0:
		// pass
	case len(m[31]) <= 9:
		trimmed := strings.TrimLeft(m[31], "0")
		if len(trimmed) > 0 {
			nanoseconds, err = strconv.ParseInt(trimmed, 10, 64)
			if err != nil {
				err = fmt.Errorf(
					"failed to parse nanoseconds from: %s",
					err.Error())
			}

			order := 9 - len(m[31])
			for i := 0; i < order; i++ {
				nanoseconds *= 10
			}
		}
	default:
		err = fmt.Errorf(
			"precision only up to nanoseconds supported")
		return
	}

	////
	// Sum
	////

	d = time.Duration(nanoseconds)

	if seconds > (math.MaxInt64 / (1000 * 1000 * 1000)) {
		err = fmt.Errorf("seconds overflow in nanoseconds")
		return
	}

	secondsAsNs := time.Duration(seconds * 1000 * 1000 * 1000)
	if secondsAsNs > math.MaxInt64 - d {
		err = fmt.Errorf(
			"overflow in nanoseconds")
		return
	}
	d += secondsAsNs

	var overflow bool
	d, overflow = addDuration(d, minutes * 6e10)
	if overflow {
		err = fmt.Errorf("overflow in nanoseconds")
		return
	}

	d, overflow = addDuration(d, hours * 3.6e12)
	if overflow {
		err = fmt.Errorf("overflow in nanoseconds")
		return
	}

	d, overflow = addDuration(d, days * 24.0 * 3.6e12)
	if overflow {
		err = fmt.Errorf("overflow in nanoseconds")
		return
	}

	d, overflow = addDuration(d, weeks * 7.0 * 24.0 * 3.6e12)
	if overflow {
		err = fmt.Errorf("overflow in nanoseconds")
		return
	}

	d, overflow = addDuration(d, months * 30.436875 * 24.0 * 3.6e12)
	if overflow {
		err = fmt.Errorf("overflow in nanoseconds")
		return
	}

	d, overflow = addDuration(d, years * 365.2425 * 24.0 * 3.6e12)
	if overflow {
		err = fmt.Errorf("overflow in nanoseconds")
		return
	}

	// d is always positive, so the multiplication by -1 can not
	// overflow since |math.MaxInt64| < |math.MinInt64|
	d *= time.Duration(sign);

	return
}

// EmptyFromJSONable parses Empty from a JSONable value.
//
// If there are any errors, the state of the target is undefined.
//
// EmptyFromJSONable requires:
//  * target != nil
//  * errors != nil
//  * errors.Empty()
func EmptyFromJSONable(
	value interface{},
	id string,
	ref string,
	target *Empty,
	errors *Errors) {

	if target == nil {
		panic("unexpected nil target")
	}

	if errors == nil {
		panic("unexpected nil errors")
	}

	if !errors.Empty() {
		panic("unexpected non-empty errors")
	}

	_, ok := value.(map[string]interface{})
	if !ok {
		errors.Add(
			ref,
			fmt.Sprintf(
				"expected a map[string]interface{}, but got: %T",
				value))
		return
	}

	target.ID = id

	return
}

// SomeEmbedFromJSONable parses SomeEmbed from a JSONable value.
//
// If there are any errors, the state of the target is undefined.
//
// SomeEmbedFromJSONable requires:
//  * target != nil
//  * errors != nil
//  * errors.Empty()
func SomeEmbedFromJSONable(
	value interface{},
	ref string,
	target *SomeEmbed,
	errors *Errors) {

	if target == nil {
		panic("unexpected nil target")
	}

	if errors == nil {
		panic("unexpected nil errors")
	}

	if !errors.Empty() {
		panic("unexpected non-empty errors")
	}

	_, ok := value.(map[string]interface{})
	if !ok {
		errors.Add(
			ref,
			fmt.Sprintf(
				"expected a map[string]interface{}, but got: %T",
				value))
		return
	}

	return
}

// SomeGraphFromJSONable parses SomeGraph from a JSONable value.
//
// If there are any errors, the state of target is undefined.
//
// SomeGraphFromJSONable requires:
//  * target != nil
//  * errors != nil
//  * errors.Empty()
func SomeGraphFromJSONable(
	value interface{},
	ref string,
	target *SomeGraph,
	errors *Errors) {

	if target == nil {
		panic("unexpected nil target")
	}

	if errors == nil {
		panic("unexpected nil errors")
	}

	if !errors.Empty() {
		panic("unexpected non-empty errors")
	}

	cast, ok := value.(map[string]interface{})
	if !ok {
		errors.Add(
			ref,
			fmt.Sprintf(
				"expected a map[string]interface{}, but got: %T",
				value))
		return
	}

	////
	// Pre-allocate Empties
	////

	emptiesRef := ref+"/empties";
	var emptiesOk bool
	var emptiesValue interface{}
	var emptiesMap map[string]interface{}

	emptiesValue, emptiesOk = cast[
		"empties"]
	if emptiesOk {
		emptiesMap, ok = emptiesValue.(map[string]interface{})
		if !ok {
			errors.Add(
				emptiesRef,
				fmt.Sprintf(
					"expected a map[string]interface{}, but got: %T",
					emptiesValue));
		} else {
			target.Empties = make(
				map[string]*Empty)

			for id := range emptiesMap {
				target.Empties[id] = &Empty{}
			}
		}
	}

	// Pre-allocating class instances is critical.
	// If the pre-allocation failed, we can not continue to parse the instances.
	if !errors.Empty() {
		return
	}

	////
	// Parse Empties
	////

	if emptiesOk {
		for id, value := range emptiesMap {
			EmptyFromJSONable(
				value,
				id,
				strings.Join([]string{
					emptiesRef, id}, "/"),
				target.Empties[id],
				errors)

			if errors.Full() {
				break
			}
		}
	}

	if errors.Full() {
		return
	}

	////
	// Parse OptionalArray
	////

	value0, ok0 := cast[
		"optional_array"]

	if ok0 {
		cast1, ok1 := value0.([]interface{})
		if !ok1 {
			errors.Add(
				strings.Join(
					[]string{
						ref, "optional_array"},
					"/"),
				fmt.Sprintf(
					"expected a []interface{}, but got: %T",
					value0))
		} else {
			target1 := make(
				[]int64,
				len(cast1))
			for i1 := range cast1 {
				fcast2, ok2 := (cast1[i1]).(float64)
				if !ok2 {
					errors.Add(
						strings.Join(
							[]string{
								ref, "optional_array", strconv.Itoa(i1)},
							"/"),
						fmt.Sprintf(
							"expected a float64, but got: %T",
							cast1[i1]))
				} else if fcast2 != math.Trunc(fcast2) {
					errors.Add(
						strings.Join(
							[]string{
								ref, "optional_array", strconv.Itoa(i1)},
							"/"),
						fmt.Sprintf(
							"expected a whole number, but got: %f",
							fcast2))
				// 9223372036854775808.0 == 2^63 is the first float > MaxInt64.
				// -9223372036854775808.0 == -(2^63) is the last float >= MinInt64.
				} else if fcast2 >= 9223372036854775808.0 ||
					fcast2 < -9223372036854775808.0 {

					errors.Add(
						strings.Join(
							[]string{
								ref, "optional_array", strconv.Itoa(i1)},
							"/"),
						fmt.Sprintf(
							"expected the value to fit into int64, but got an overflow: %f",
							fcast2))
				} else {
					target1[i1] = int64(fcast2)
				}

				if errors.Full() {
					break;
				}
			}

			target.OptionalArray = target1
		}
	}

	if errors.Full() {
		return
	}

	////
	// Parse OptionalBoolean
	////

	value3, ok3 := cast[
		"optional_boolean"]

	if ok3 {
		var target3 bool
		cast4, ok4 := value3.(bool)
		if !ok4 {
			errors.Add(
				strings.Join(
					[]string{
						ref, "optional_boolean"},
					"/"),
				fmt.Sprintf(
					"expected a bool, but got: %T",
					value3))
		} else {
			target3 = cast4
		}

		target.OptionalBoolean = &target3
	}

	if errors.Full() {
		return
	}

	////
	// Parse OptionalDate
	////

	value5, ok5 := cast[
		"optional_date"]

	if ok5 {
		var target5 time.Time
		cast6, ok6 := value5.(string)
		if !ok6 {
			errors.Add(
				strings.Join(
					[]string{
						ref, "optional_date"},
					"/"),
				fmt.Sprintf(
					"expected a string, but got: %T",
					value5))
		} else {
			target6, err6 := time.Parse(
				"2006-01-02",
				cast6)
			if err6 != nil {
				errors.Add(
					strings.Join(
						[]string{
							ref, "optional_date"},
						"/"),
					fmt.Sprintf(
						"expected layout 2006-01-02, got: %s",
						cast6))
			} else {
				target5 = target6
			}
		}

		target.OptionalDate = &target5
	}

	if errors.Full() {
		return
	}

	////
	// Parse OptionalDatetime
	////

	value7, ok7 := cast[
		"optional_datetime"]

	if ok7 {
		var target7 time.Time
		cast8, ok8 := value7.(string)
		if !ok8 {
			errors.Add(
				strings.Join(
					[]string{
						ref, "optional_datetime"},
					"/"),
				fmt.Sprintf(
					"expected a string, but got: %T",
					value7))
		} else {
			target8, err8 := time.Parse(
				"2006-01-02T15:04:05Z",
				cast8)
			if err8 != nil {
				errors.Add(
					strings.Join(
						[]string{
							ref, "optional_datetime"},
						"/"),
					fmt.Sprintf(
						"expected layout 2006-01-02T15:04:05Z, got: %s",
						cast8))
			} else {
				target7 = target8
			}
		}

		target.OptionalDatetime = &target7
	}

	if errors.Full() {
		return
	}

	////
	// Parse OptionalDuration
	////

	value9, ok9 := cast[
		"optional_duration"]

	if ok9 {
		var target9 time.Duration
		cast10, ok10 := value9.(string)
		if !ok10 {
			errors.Add(
				strings.Join(
					[]string{
						ref, "optional_duration"},
					"/"),
				fmt.Sprintf(
					"expected a string, but got: %T",
					value9))
		} else {
			target10, err10 := durationFromString(cast10)
			if err10 != nil {
				errors.Add(
					strings.Join(
						[]string{
							ref, "optional_duration"},
						"/"),
					fmt.Sprintf(
						"failed to parse duration from %#v: %s",
						cast10,
						err10.Error()))
			} else {
				target9 = target10
			}
		}

		target.OptionalDuration = &target9
	}

	if errors.Full() {
		return
	}

	////
	// Parse OptionalFloat
	////

	value11, ok11 := cast[
		"optional_float"]

	if ok11 {
		var target11 float64
		cast12, ok12 := value11.(float64)
		if !ok12 {
			errors.Add(
				strings.Join(
					[]string{
						ref, "optional_float"},
					"/"),
				fmt.Sprintf(
					"expected a float64, but got: %T",
					value11))
		} else {
			target11 = cast12
		}

		target.OptionalFloat = &target11
	}

	if errors.Full() {
		return
	}

	////
	// Parse OptionalInteger
	////

	value13, ok13 := cast[
		"optional_integer"]

	if ok13 {
		var target13 int64
		fcast14, ok14 := value13.(float64)
		if !ok14 {
			errors.Add(
				strings.Join(
					[]string{
						ref, "optional_integer"},
					"/"),
				fmt.Sprintf(
					"expected a float64, but got: %T",
					value13))
		} else if fcast14 != math.Trunc(fcast14) {
			errors.Add(
				strings.Join(
					[]string{
						ref, "optional_integer"},
					"/"),
				fmt.Sprintf(
					"expected a whole number, but got: %f",
					fcast14))
		// 9223372036854775808.0 == 2^63 is the first float > MaxInt64.
		// -9223372036854775808.0 == -(2^63) is the last float >= MinInt64.
		} else if fcast14 >= 9223372036854775808.0 ||
			fcast14 < -9223372036854775808.0 {

			errors.Add(
				strings.Join(
					[]string{
						ref, "optional_integer"},
					"/"),
				fmt.Sprintf(
					"expected the value to fit into int64, but got an overflow: %f",
					fcast14))
		} else {
			target13 = int64(fcast14)
		}

		target.OptionalInteger = &target13
	}

	if errors.Full() {
		return
	}

	////
	// Parse OptionalMap
	////

	value15, ok15 := cast[
		"optional_map"]

	if ok15 {
		cast16, ok16 := value15.(map[string]interface{})
		if !ok16 {
			errors.Add(
				strings.Join(
					[]string{
						ref, "optional_map"},
					"/"),
				fmt.Sprintf(
					"expected a map[string]interface{}, but got: %T",
					value15))
		} else {
			target16 := make(map[string]int64)
			for k16 := range cast16 {
				fcast17, ok17 := (cast16[k16]).(float64)
				if !ok17 {
					errors.Add(
						strings.Join(
							[]string{
								ref, "optional_map", k16},
							"/"),
						fmt.Sprintf(
							"expected a float64, but got: %T",
							cast16[k16]))
				} else if fcast17 != math.Trunc(fcast17) {
					errors.Add(
						strings.Join(
							[]string{
								ref, "optional_map", k16},
							"/"),
						fmt.Sprintf(
							"expected a whole number, but got: %f",
							fcast17))
				// 9223372036854775808.0 == 2^63 is the first float > MaxInt64.
				// -9223372036854775808.0 == -(2^63) is the last float >= MinInt64.
				} else if fcast17 >= 9223372036854775808.0 ||
					fcast17 < -9223372036854775808.0 {

					errors.Add(
						strings.Join(
							[]string{
								ref, "optional_map", k16},
							"/"),
						fmt.Sprintf(
							"expected the value to fit into int64, but got an overflow: %f",
							fcast17))
				} else {
					target16[k16] = int64(fcast17)
				}

				if errors.Full() {
					break;
				}
			}

			target.OptionalMap = target16
		}
	}

	if errors.Full() {
		return
	}

	////
	// Parse OptionalPath
	////

	value18, ok18 := cast[
		"optional_path"]

	if ok18 {
		var target18 string
		cast19, ok19 := value18.(string)
		if !ok19 {
			errors.Add(
				strings.Join(
					[]string{
						ref, "optional_path"},
					"/"),
				fmt.Sprintf(
					"expected a string, but got: %T",
					value18))
		} else {
			target18 = cast19
		}

		target.OptionalPath = &target18
	}

	if errors.Full() {
		return
	}

	////
	// Parse OptionalString
	////

	value20, ok20 := cast[
		"optional_string"]

	if ok20 {
		var target20 string
		cast21, ok21 := value20.(string)
		if !ok21 {
			errors.Add(
				strings.Join(
					[]string{
						ref, "optional_string"},
					"/"),
				fmt.Sprintf(
					"expected a string, but got: %T",
					value20))
		} else {
			target20 = cast21
		}

		target.OptionalString = &target20
	}

	if errors.Full() {
		return
	}

	////
	// Parse OptionalTime
	////

	value22, ok22 := cast[
		"optional_time"]

	if ok22 {
		var target22 time.Time
		cast23, ok23 := value22.(string)
		if !ok23 {
			errors.Add(
				strings.Join(
					[]string{
						ref, "optional_time"},
					"/"),
				fmt.Sprintf(
					"expected a string, but got: %T",
					value22))
		} else {
			target23, err23 := time.Parse(
				"15:04:05",
				cast23)
			if err23 != nil {
				errors.Add(
					strings.Join(
						[]string{
							ref, "optional_time"},
						"/"),
					fmt.Sprintf(
						"expected layout 15:04:05, got: %s",
						cast23))
			} else {
				target22 = target23
			}
		}

		target.OptionalTime = &target22
	}

	if errors.Full() {
		return
	}

	////
	// Parse OptionalTimeZone
	////

	value24, ok24 := cast[
		"optional_time_zone"]

	if ok24 {
		cast25, ok25 := value24.(string)
		if !ok25 {
			errors.Add(
				strings.Join(
					[]string{
						ref, "optional_time_zone"},
					"/"),
				fmt.Sprintf(
					"expected a string, but got: %T",
					value24))
		} else {
			target25, err25 := time.LoadLocation(cast25)
			if err25 != nil {
				errors.Add(
					strings.Join(
						[]string{
							ref, "optional_time_zone"},
						"/"),
					fmt.Sprintf(
						"failed to load location from %#v: %s",
						cast25,
						err25.Error()))
			} else {
				target.OptionalTimeZone = target25
			}
		}
	}

	if errors.Full() {
		return
	}

	////
	// Parse OptionalReference
	////

	value26, ok26 := cast[
		"optional_reference"]

	if ok26 {
		cast27, ok27 := value26.(string)
		if !ok27 {
			errors.Add(
				strings.Join(
					[]string{
						ref, "optional_reference"},
					"/"),
				fmt.Sprintf(
					"expected a string, but got: %T",
					value26))
		} else {
			target27, ok27 := target.Empties[cast27]
			if !ok27 {
				errors.Add(
					strings.Join(
						[]string{
							ref, "optional_reference"},
						"/"),
					fmt.Sprintf(
						"reference to an instance of class Empty not found: %s",
						value26))
			} else {
				target.OptionalReference = target27
			}
		}
	}

	if errors.Full() {
		return
	}

	////
	// Parse OptionalEmbed
	////

	value28, ok28 := cast[
		"optional_embed"]

	if ok28 {
		var target28 SomeEmbed
		SomeEmbedFromJSONable(
			value28,
			strings.Join(
				[]string{
					ref, "optional_embed"},
				"/"),
			&(target28),
			errors)

		target.OptionalEmbed = &target28
	}

	if errors.Full() {
		return
	}

	return
}

// File automatically generated by mapry. DO NOT EDIT OR APPEND!
