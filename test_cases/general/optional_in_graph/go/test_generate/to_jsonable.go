package somegraph

// File automatically generated by mapry. DO NOT EDIT OR APPEND!

import (
	"fmt"
	"strings"
	"time"
)

// durationToString represents the duration as a string in ISO 8601 format.
//
// Since time.Duration stores intervals as nanoseconds and excludes longer
// intervals such as minutes, days or months, durationToString
// infers the integral number of these longer intervals and
// produces a compact representation.
func durationToString(d time.Duration) string {
	parts := make([]string, 0, 7)

	////
	// Interprete
	////

	sign := 1
	if d < 0 {
		d = -d
		sign = -1
	}

	days := d / (24 * time.Hour)
	rest := d % (24 * time.Hour)

	hours := rest / time.Hour
	rest = rest % time.Hour

	minutes := rest / time.Minute
	rest = rest % time.Minute

	seconds := rest / time.Second
	rest = rest % time.Second

	nanoseconds := rest

	////
	// Represent
	////

	if sign < 0 {
		parts = append(parts, "-")
	}

	parts = append(parts, "P")

	if days > 0 {
		parts = append(
			parts,
			fmt.Sprintf("%dD", days))
	}

	if hours > 0 || minutes > 0 || seconds > 0 || nanoseconds > 0 {
		parts = append(parts, "T")

		if hours > 0 {
			parts = append(
				parts,
				fmt.Sprintf("%dH", hours))
		}

		if minutes > 0 {
			parts = append(
				parts,
				fmt.Sprintf("%dM", minutes))
		}

		if nanoseconds == 0 {
			if seconds > 0 {
				parts = append(
					parts,
					fmt.Sprintf("%dS", seconds))
			}
		} else {
			parts = append(
				parts,
				strings.TrimRight(
					fmt.Sprintf("%d.%09d", seconds, nanoseconds),
					"0"))
			parts = append(parts, "S")
		}
	}

	return strings.Join(parts, "")
}

// EmptyToJSONable converts the instance to
// a JSONable representation.
//
// EmptyToJSONable requires:
//  * instance != nil
//
// EmptyToJSONable ensures:
//  * target != nil
func EmptyToJSONable(
	instance *Empty) (
	target map[string]interface{}) {

	if instance == nil {
		panic("unexpected nil instance")
	}

	target = make(map[string]interface{})

	return
}

// SomeEmbedToJSONable converts the instance to
// a JSONable representation.
//
// SomeEmbedToJSONable requires:
//  * instance != nil
//
// SomeEmbedToJSONable ensures:
//  * target != nil
func SomeEmbedToJSONable(
	instance *SomeEmbed) (
	target map[string]interface{}) {

	if instance == nil {
		panic("unexpected nil instance")
	}

	target = make(map[string]interface{})

	return
}

// SomeGraph converts the instance to a JSONable representation.
//
// SomeGraph requires:
//  * instance != nil
//
// SomeGraph ensures:
//  * (err == nil && target != nil) || (err != nil && target == nil)
func SomeGraphToJSONable(
	instance *SomeGraph) (
	target map[string]interface{}, err error) {

	if instance == nil {
		panic("unexpected nil instance")
	}

	target = make(map[string]interface{})
	defer func() {
		if err != nil {
			target = nil
		}
	}()
	////
	// Serialize OptionalArray
	////

	if instance.OptionalArray != nil {
		count0 := len(instance.OptionalArray)
		slice0 := instance.OptionalArray
		target0 := make([]interface{}, count0)
		for i0 := 0; i0 < count0; i0++ {
			target0[i0] = slice0[i0]
		}
		target["optional_array"] = target0
	}

	////
	// Serialize OptionalBoolean
	////

	if instance.OptionalBoolean != nil {
		target["optional_boolean"] = (*instance.OptionalBoolean)
	}

	////
	// Serialize OptionalDate
	////

	if instance.OptionalDate != nil {
		target["optional_date"] = (*instance.OptionalDate).Format(
			"2006-01-02")
	}

	////
	// Serialize OptionalDatetime
	////

	if instance.OptionalDatetime != nil {
		target["optional_datetime"] = (*instance.OptionalDatetime).Format(
			"2006-01-02T15:04:05Z")
	}

	////
	// Serialize OptionalDuration
	////

	if instance.OptionalDuration != nil {
		target["optional_duration"] = durationToString(
			(*instance.OptionalDuration))
	}

	////
	// Serialize OptionalFloat
	////

	if instance.OptionalFloat != nil {
		target["optional_float"] = (*instance.OptionalFloat)
	}

	////
	// Serialize OptionalInteger
	////

	if instance.OptionalInteger != nil {
		target["optional_integer"] = (*instance.OptionalInteger)
	}

	////
	// Serialize OptionalMap
	////

	if instance.OptionalMap != nil {
		target1 := make(map[string]interface{})
		map1 := instance.OptionalMap
		for k1, v1 := range map1 {
			target1[k1] = v1
		}
		target["optional_map"] = target1
	}

	////
	// Serialize OptionalPath
	////

	if instance.OptionalPath != nil {
		target["optional_path"] = (*instance.OptionalPath)
	}

	////
	// Serialize OptionalString
	////

	if instance.OptionalString != nil {
		target["optional_string"] = (*instance.OptionalString)
	}

	////
	// Serialize OptionalTime
	////

	if instance.OptionalTime != nil {
		target["optional_time"] = (*instance.OptionalTime).Format(
			"15:04:05")
	}

	////
	// Serialize OptionalTimeZone
	////

	if instance.OptionalTimeZone != nil {
		target["optional_time_zone"] = instance.OptionalTimeZone.String()
	}

	////
	// Serialize OptionalReference
	////

	if instance.OptionalReference != nil {
		target["optional_reference"] = instance.OptionalReference.ID
	}

	////
	// Serialize OptionalEmbed
	////

	if instance.OptionalEmbed != nil {
		target["optional_embed"] = SomeEmbedToJSONable(
			&(*instance.OptionalEmbed))
	}

	////
	// Serialize instance registry of Empty
	////

	if len(instance.Empties) > 0 {
		targetEmpties := make(map[string]interface{})
		for id := range instance.Empties {
			emptyInstance := instance.Empties[id]

			if id != emptyInstance.ID {
				err = fmt.Errorf(
					"expected the instance of Empty to have the ID %s according to the registry, but got: %s",
					id, emptyInstance.ID)
				return
			}

			targetEmpties[id] = EmptyToJSONable(
				emptyInstance)
		}

		target["empties"] = targetEmpties
	}

	return
}

// File automatically generated by mapry. DO NOT EDIT OR APPEND!
