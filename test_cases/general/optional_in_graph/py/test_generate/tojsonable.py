# File automatically generated by mapry. DO NOT EDIT OR APPEND!


"""serializes to JSONable objects."""


import collections
import datetime
import typing

import some.graph


_ZERO_TIMEDELTA = datetime.timedelta(0)


def _duration_to_string(
        duration: datetime.timedelta) -> str:
    """
    serializes the duration to a string in ISO 8601 format.

    Since ``datetime.timedelta`` stores intervals only up to days and
    excludes longer intervals such as weeks, months and years,
    the serialized representation defines the duration only
    in terms of days and shorter intervals.

    :param duration: duration to be serialized
    :return: text representation

    >>> _duration_to_string(
    ...     datetime.timedelta(days=1, hours=2, minutes=3,
    ...     seconds=4, microseconds=5))
    'P1DT2H3M4.000005S'

    >>> _duration_to_string(
    ...     datetime.timedelta(hours=1, minutes=2, seconds=3))
    'PT1H2M3S'

    >>> _duration_to_string(
    ...     datetime.timedelta(seconds=1))
    'PT1S'

    >>> _duration_to_string(
    ...     datetime.timedelta(days=365.1))
    'P365DT2H24M'

    >>> _duration_to_string(
    ...     -datetime.timedelta(days=1))
    '-P1D'

    >>> _duration_to_string(
    ...     -datetime.timedelta(
    ...         days=1, hours=1, minutes=1,seconds=1,microseconds=1))
    '-P1DT1H1M1.000001S'

    """
    parts = []  # type: typing.List[str]

    absduration = duration
    if duration < _ZERO_TIMEDELTA:
        parts.append('-')
        absduration = -duration

    parts.append('P')
    if absduration.days > 0:
        parts.append('{}D'.format(absduration.days))

    if absduration.seconds > 0 or absduration.microseconds > 0:
        parts.append('T')

        rest = absduration.seconds
        hours = rest // 3600
        rest = rest % 3600

        minutes = rest // 60
        seconds = rest % 60

        if hours > 0:
            parts.append('{}H'.format(hours))

        if minutes > 0:
            parts.append('{}M'.format(minutes))

        if absduration.microseconds > 0:
            microseconds_str = '{:06}'.format(
                absduration.microseconds).rstrip('0')

            parts.append('{}.{}S'.format(seconds, microseconds_str))
        elif seconds > 0:
            parts.append('{}S'.format(seconds))
        else:
            # No microseconds nor seconds
            pass

    return ''.join(parts)


def serialize_empty(
        instance: some.graph.Empty,
        ordered: bool = False
) -> typing.MutableMapping[str, typing.Any]:
    """
    serializes an instance of Empty to a JSONable representation.

    :param instance: the instance of Empty to be serialized
    :param ordered:
        If set, represents the instance as a ``collections.OrderedDict``.
        Otherwise, it is represented as a ``dict``.
    :return: a JSONable
    """
    if ordered:
        target = (
            collections.OrderedDict()
        )  # type: typing.MutableMapping[str, typing.Any]
    else:
        target = dict()

    return target


def serialize_some_embed(
        instance: some.graph.SomeEmbed,
        ordered: bool = False
) -> typing.MutableMapping[str, typing.Any]:
    """
    serializes an instance of SomeEmbed to a JSONable representation.

    :param instance: the instance of SomeEmbed to be serialized
    :param ordered:
        If set, represents the instance as a ``collections.OrderedDict``.
        Otherwise, it is represented as a ``dict``.
    :return: a JSONable
    """
    if ordered:
        target = (
            collections.OrderedDict()
        )  # type: typing.MutableMapping[str, typing.Any]
    else:
        target = dict()

    return target


def serialize_some_graph(
        instance: some.graph.SomeGraph,
        ordered: bool = False
) -> typing.MutableMapping[str, typing.Any]:
    """
    serializes an instance of SomeGraph to a JSONable.

    :param instance: the instance of SomeGraph to be serialized
    :param ordered:
        If set, represents the instance properties and class registries
        as a ``collections.OrderedDict``.
        Otherwise, they are represented as a ``dict``.
    :return: JSONable representation
    """
    if ordered:
        target = (
            collections.OrderedDict()
        )  # type: typing.MutableMapping[str, typing.Any]
    else:
        target = dict()

    ##
    # Serialize optional_array
    ##

    if instance.optional_array is not None:
        target['optional_array'] = (
            instance.optional_array[:]
        )

    ##
    # Serialize optional_boolean
    ##

    if instance.optional_boolean is not None:
        target['optional_boolean'] = instance.optional_boolean

    ##
    # Serialize optional_date
    ##

    if instance.optional_date is not None:
        target['optional_date'] = instance.optional_date.strftime('%Y-%m-%d')

    ##
    # Serialize optional_datetime
    ##

    if instance.optional_datetime is not None:
        target['optional_datetime'] = instance.optional_datetime.strftime('%Y-%m-%dT%H:%M:%SZ')

    ##
    # Serialize optional_duration
    ##

    if instance.optional_duration is not None:
        target['optional_duration'] = _duration_to_string(instance.optional_duration)

    ##
    # Serialize optional_float
    ##

    if instance.optional_float is not None:
        target['optional_float'] = instance.optional_float

    ##
    # Serialize optional_integer
    ##

    if instance.optional_integer is not None:
        target['optional_integer'] = instance.optional_integer

    ##
    # Serialize optional_map
    ##

    if instance.optional_map is not None:
        if isinstance(instance.optional_map, collections.OrderedDict):
            target_1 = (
                collections.OrderedDict()
            )  # type: typing.MutableMapping[str, int]
        else:
            target_1 = dict()

        for key_1, value_1 in instance.optional_map.items():
            target_1[key_1] = value_1
        target['optional_map'] = target_1

    ##
    # Serialize optional_path
    ##

    if instance.optional_path is not None:
        target['optional_path'] = str(instance.optional_path)

    ##
    # Serialize optional_string
    ##

    if instance.optional_string is not None:
        target['optional_string'] = instance.optional_string

    ##
    # Serialize optional_time
    ##

    if instance.optional_time is not None:
        target['optional_time'] = instance.optional_time.strftime('%H:%M:%S')

    ##
    # Serialize optional_time_zone
    ##

    if instance.optional_time_zone is not None:
        target['optional_time_zone'] = instance.optional_time_zone

    ##
    # Serialize optional_reference
    ##

    if instance.optional_reference is not None:
        target['optional_reference'] = instance.optional_reference.id

    ##
    # Serialize optional_embed
    ##

    if instance.optional_embed is not None:
        target['optional_embed'] = serialize_some_embed(instance.optional_embed)

    ##
    # Serialize instance registry of Empty
    ##

    if len(instance.empties) > 0:
        if ordered:
            target_empties = (
                collections.OrderedDict()
            )  # type: typing.MutableMapping[str, typing.Any]
        else:
            target_empties = dict()

        for id, empty_instance in instance.empties.items():
            if id != empty_instance.id:
                raise ValueError(
                    'Expected ID {!r} of the instance of Empty, but got: {!r}'.format(
                        id, empty_instance.id))

            target_empties[id] = serialize_empty(
                instance=empty_instance,
                ordered=ordered)
        target['empties'] = target_empties

    return target


# File automatically generated by mapry. DO NOT EDIT OR APPEND!
