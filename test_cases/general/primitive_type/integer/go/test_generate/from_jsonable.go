package somegraph

// File automatically generated by mapry. DO NOT EDIT OR APPEND!

import (
	"fmt"
	"math"
	"strings"
)

// SomeGraphFromJSONable parses SomeGraph from a JSONable value.
//
// If there are any errors, the state of target is undefined.
//
// SomeGraphFromJSONable requires:
//  * target != nil
//  * errors != nil
//  * errors.Empty()
func SomeGraphFromJSONable(
	value interface{},
	ref string,
	target *SomeGraph,
	errors *Errors) {

	if target == nil {
		panic("unexpected nil target")
	}

	if errors == nil {
		panic("unexpected nil errors")
	}

	if !errors.Empty() {
		panic("unexpected non-empty errors")
	}

	cast, ok := value.(map[string]interface{})
	if !ok {
		errors.Add(
			ref,
			fmt.Sprintf(
				"expected a map[string]interface{}, but got: %T",
				value))
		return
	}

	////
	// Parse SomeIntGt0Lt100
	////

	value0, ok0 := cast[
		"some_int_gt_0_lt_100"]

	if !ok0 {
		errors.Add(
			ref,
			"property is missing: some_int_gt_0_lt_100")
	} else {
		fcast1, ok1 := value0.(float64)
		if !ok1 {
			errors.Add(
				strings.Join(
					[]string{
						ref, "some_int_gt_0_lt_100"},
					"/"),
				fmt.Sprintf(
					"expected a float64, but got: %T",
					value0))
		} else if fcast1 != math.Trunc(fcast1) {
			errors.Add(
				strings.Join(
					[]string{
						ref, "some_int_gt_0_lt_100"},
					"/"),
				fmt.Sprintf(
					"expected a whole number, but got: %f",
					fcast1))
		// 9223372036854775808.0 == 2^63 is the first float > MaxInt64.
		// -9223372036854775808.0 == -(2^63) is the last float >= MinInt64.
		} else if fcast1 >= 9223372036854775808.0 ||
			fcast1 < -9223372036854775808.0 {

			errors.Add(
				strings.Join(
					[]string{
						ref, "some_int_gt_0_lt_100"},
					"/"),
				fmt.Sprintf(
					"expected the value to fit into int64, but got an overflow: %f",
					fcast1))
		} else {
			cast1 := int64(fcast1)

			if !(cast1 > 0) {
				errors.Add(
					strings.Join(
						[]string{
							ref, "some_int_gt_0_lt_100"},
						"/"),
					fmt.Sprintf(
						"expected > 0, but got: %d",
						cast1))
			} else if !(cast1 < 100) {
				errors.Add(
					strings.Join(
						[]string{
							ref, "some_int_gt_0_lt_100"},
							"/"),
					fmt.Sprintf(
						"expected < 100, but got: %d",
						cast1))
			} else {
				target.SomeIntGt0Lt100 = cast1
			}
		}
	}

	if errors.Full() {
		return
	}

	////
	// Parse SomeIntGe0Le100
	////

	value2, ok2 := cast[
		"some_int_ge_0_le_100"]

	if !ok2 {
		errors.Add(
			ref,
			"property is missing: some_int_ge_0_le_100")
	} else {
		fcast3, ok3 := value2.(float64)
		if !ok3 {
			errors.Add(
				strings.Join(
					[]string{
						ref, "some_int_ge_0_le_100"},
					"/"),
				fmt.Sprintf(
					"expected a float64, but got: %T",
					value2))
		} else if fcast3 != math.Trunc(fcast3) {
			errors.Add(
				strings.Join(
					[]string{
						ref, "some_int_ge_0_le_100"},
					"/"),
				fmt.Sprintf(
					"expected a whole number, but got: %f",
					fcast3))
		// 9223372036854775808.0 == 2^63 is the first float > MaxInt64.
		// -9223372036854775808.0 == -(2^63) is the last float >= MinInt64.
		} else if fcast3 >= 9223372036854775808.0 ||
			fcast3 < -9223372036854775808.0 {

			errors.Add(
				strings.Join(
					[]string{
						ref, "some_int_ge_0_le_100"},
					"/"),
				fmt.Sprintf(
					"expected the value to fit into int64, but got an overflow: %f",
					fcast3))
		} else {
			cast3 := int64(fcast3)

			if !(cast3 >= 0) {
				errors.Add(
					strings.Join(
						[]string{
							ref, "some_int_ge_0_le_100"},
						"/"),
					fmt.Sprintf(
						"expected >= 0, but got: %d",
						cast3))
			} else if !(cast3 <= 100) {
				errors.Add(
					strings.Join(
						[]string{
							ref, "some_int_ge_0_le_100"},
							"/"),
					fmt.Sprintf(
						"expected <= 100, but got: %d",
						cast3))
			} else {
				target.SomeIntGe0Le100 = cast3
			}
		}
	}

	if errors.Full() {
		return
	}

	////
	// Parse UnconstrainedInt
	////

	value4, ok4 := cast[
		"unconstrained_int"]

	if !ok4 {
		errors.Add(
			ref,
			"property is missing: unconstrained_int")
	} else {
		fcast5, ok5 := value4.(float64)
		if !ok5 {
			errors.Add(
				strings.Join(
					[]string{
						ref, "unconstrained_int"},
					"/"),
				fmt.Sprintf(
					"expected a float64, but got: %T",
					value4))
		} else if fcast5 != math.Trunc(fcast5) {
			errors.Add(
				strings.Join(
					[]string{
						ref, "unconstrained_int"},
					"/"),
				fmt.Sprintf(
					"expected a whole number, but got: %f",
					fcast5))
		// 9223372036854775808.0 == 2^63 is the first float > MaxInt64.
		// -9223372036854775808.0 == -(2^63) is the last float >= MinInt64.
		} else if fcast5 >= 9223372036854775808.0 ||
			fcast5 < -9223372036854775808.0 {

			errors.Add(
				strings.Join(
					[]string{
						ref, "unconstrained_int"},
					"/"),
				fmt.Sprintf(
					"expected the value to fit into int64, but got an overflow: %f",
					fcast5))
		} else {
			target.UnconstrainedInt = int64(fcast5)
		}
	}

	if errors.Full() {
		return
	}

	return
}

// File automatically generated by mapry. DO NOT EDIT OR APPEND!
